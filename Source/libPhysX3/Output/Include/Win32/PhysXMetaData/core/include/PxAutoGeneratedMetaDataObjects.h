// This code contains NVIDIA Confidential Information and is disclosed to you 
// under a form of NVIDIA software license agreement provided separately to you.
//
// Notice
// NVIDIA Corporation and its licensors retain all intellectual property and
// proprietary rights in and to this software and related documentation and 
// any modifications thereto. Any use, reproduction, disclosure, or 
// distribution of this software and related documentation without an express 
// license agreement from NVIDIA Corporation is strictly prohibited.
// 
// ALL NVIDIA DESIGN SPECIFICATIONS, CODE ARE PROVIDED "AS IS.". NVIDIA MAKES
// NO WARRANTIES, EXPRESSED, IMPLIED, STATUTORY, OR OTHERWISE WITH RESPECT TO
// THE MATERIALS, AND EXPRESSLY DISCLAIMS ALL IMPLIED WARRANTIES OF NONINFRINGEMENT,
// MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE.
//
// Information and code furnished is believed to be accurate and reliable.
// However, NVIDIA Corporation assumes no responsibility for the consequences of use of such
// information or for any infringement of patents or other rights of third parties that may
// result from its use. No license is granted by implication or otherwise under any patent
// or patent rights of NVIDIA Corporation. Details are subject to change without notice.
// This code supersedes and replaces all information previously supplied.
// NVIDIA Corporation products are not authorized for use as critical
// components in life support devices or systems without express written approval of
// NVIDIA Corporation.
//
// Copyright (c) 2008-2011 NVIDIA Corporation. All rights reserved.
// Copyright (c) 2004-2008 AGEIA Technologies, Inc. All rights reserved.
// Copyright (c) 2001-2004 NovodeX AG. All rights reserved.

// This code is auto-generated by the PhysX Clang metadata generator.  Do not edit or be
// prepared for your edits to be quietly ignored next time the clang metadata generator is
// run.  You can find the most recent version of clang metadata generator by contacting
// Chris Nuernberger <chrisn@nvidia.com> or Dilip or Adam.
// The source code for the generate was at one time checked into:
// physx/PhysXMetaDataGenerator/llvm/tools/clang/lib/Frontend/PhysXMetaDataAction.cpp
#define THERE_IS_NO_INCLUDE_GUARD_HERE_FOR_A_REASON

#define PX_PROPERTY_INFO_NAME PxPropertyInfoName
	static PxU32ToName g_PxHeightFieldFormat__EnumConversion[] = {
		{ "eS16_TM", static_cast<PxU32>( PxHeightFieldFormat::eS16_TM ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< PxHeightFieldFormat::Enum > { PxEnumTraits() : NameConversion( g_PxHeightFieldFormat__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	static PxU32ToName g_PxHeightFieldFlag__EnumConversion[] = {
		{ "eNO_BOUNDARY_EDGES", static_cast<PxU32>( PxHeightFieldFlag::eNO_BOUNDARY_EDGES ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< PxHeightFieldFlag::Enum > { PxEnumTraits() : NameConversion( g_PxHeightFieldFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxHeightFieldDesc;
	struct PxHeightFieldDescGeneratedValues
	{
		_Bool IsValid;
		PxU32 NbRows;
		PxU32 NbColumns;
		PxHeightFieldFormat::Enum Format;
		PxStridedData Samples;
		PxReal Thickness;
		PxReal ConvexEdgeThreshold;
		PxHeightFieldFlags Flags;
		void PX_PHYSX_CORE_API getValues( const PxHeightFieldDesc* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxHeightFieldDesc, IsValid, PxHeightFieldDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxHeightFieldDesc, NbRows, PxHeightFieldDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxHeightFieldDesc, NbColumns, PxHeightFieldDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxHeightFieldDesc, Format, PxHeightFieldDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxHeightFieldDesc, Samples, PxHeightFieldDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxHeightFieldDesc, Thickness, PxHeightFieldDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxHeightFieldDesc, ConvexEdgeThreshold, PxHeightFieldDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxHeightFieldDesc, Flags, PxHeightFieldDescGeneratedValues)
	struct PxHeightFieldDescGeneratedInfo

	{
		static const char* getClassName() { return "PxHeightFieldDesc"; }
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxHeightFieldDesc_IsValid, PxHeightFieldDesc, _Bool > IsValid;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxHeightFieldDesc_NbRows, PxHeightFieldDesc, PxU32, PxU32 > NbRows;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxHeightFieldDesc_NbColumns, PxHeightFieldDesc, PxU32, PxU32 > NbColumns;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxHeightFieldDesc_Format, PxHeightFieldDesc, PxHeightFieldFormat::Enum, PxHeightFieldFormat::Enum > Format;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxHeightFieldDesc_Samples, PxHeightFieldDesc, PxStridedData, PxStridedData > Samples;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxHeightFieldDesc_Thickness, PxHeightFieldDesc, PxReal, PxReal > Thickness;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxHeightFieldDesc_ConvexEdgeThreshold, PxHeightFieldDesc, PxReal, PxReal > ConvexEdgeThreshold;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxHeightFieldDesc_Flags, PxHeightFieldDesc, PxHeightFieldFlags, PxHeightFieldFlags > Flags;

		PX_PHYSX_CORE_API PxHeightFieldDescGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxHeightFieldDesc*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 8; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		void visitInstanceProperty( TOperator inOperator, PxU32 inPropIdx, PxU32 inStartIndex = 0 ) const
		{
			switch( inPropIdx ) {
				case 0: inOperator( IsValid, inStartIndex + 0 );break; 
				case 1: inOperator( NbRows, inStartIndex + 1 );break; 
				case 2: inOperator( NbColumns, inStartIndex + 2 );break; 
				case 3: inOperator( Format, inStartIndex + 3 );break; 
				case 4: inOperator( Samples, inStartIndex + 4 );break; 
				case 5: inOperator( Thickness, inStartIndex + 5 );break; 
				case 6: inOperator( ConvexEdgeThreshold, inStartIndex + 6 );break; 
				case 7: inOperator( Flags, inStartIndex + 7 );break; 
				default: PX_ASSERT( false ); break;
			}
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( IsValid, inStartIndex + 0 );; 
			inOperator( NbRows, inStartIndex + 1 );; 
			inOperator( NbColumns, inStartIndex + 2 );; 
			inOperator( Format, inStartIndex + 3 );; 
			inOperator( Samples, inStartIndex + 4 );; 
			inOperator( Thickness, inStartIndex + 5 );; 
			inOperator( ConvexEdgeThreshold, inStartIndex + 6 );; 
			inOperator( Flags, inStartIndex + 7 );; 
			return 8 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxHeightFieldDesc> { PxHeightFieldDescGeneratedInfo Info; };

	static PxU32ToName g_PxGeometryType__EnumConversion[] = {
		{ "eSPHERE", static_cast<PxU32>( PxGeometryType::eSPHERE ) },
		{ "ePLANE", static_cast<PxU32>( PxGeometryType::ePLANE ) },
		{ "eCAPSULE", static_cast<PxU32>( PxGeometryType::eCAPSULE ) },
		{ "eBOX", static_cast<PxU32>( PxGeometryType::eBOX ) },
		{ "eCONVEXMESH", static_cast<PxU32>( PxGeometryType::eCONVEXMESH ) },
		{ "eTRIANGLEMESH", static_cast<PxU32>( PxGeometryType::eTRIANGLEMESH ) },
		{ "eHEIGHTFIELD", static_cast<PxU32>( PxGeometryType::eHEIGHTFIELD ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< PxGeometryType::Enum > { PxEnumTraits() : NameConversion( g_PxGeometryType__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	static PxU32ToName g_PxShapeFlag__EnumConversion[] = {
		{ "eSIMULATION_SHAPE", static_cast<PxU32>( PxShapeFlag::eSIMULATION_SHAPE ) },
		{ "eSCENE_QUERY_SHAPE", static_cast<PxU32>( PxShapeFlag::eSCENE_QUERY_SHAPE ) },
		{ "eTRIGGER_SHAPE", static_cast<PxU32>( PxShapeFlag::eTRIGGER_SHAPE ) },
		{ "eVISUALIZATION", static_cast<PxU32>( PxShapeFlag::eVISUALIZATION ) },
		{ "ePARTICLE_DRAIN", static_cast<PxU32>( PxShapeFlag::ePARTICLE_DRAIN ) },
		{ "eDEFORMABLE_DRAIN", static_cast<PxU32>( PxShapeFlag::eDEFORMABLE_DRAIN ) },
		{ "eUSE_SWEPT_BOUNDS", static_cast<PxU32>( PxShapeFlag::eUSE_SWEPT_BOUNDS ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< PxShapeFlag::Enum > { PxEnumTraits() : NameConversion( g_PxShapeFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxShape;
	struct PxShapeGeneratedValues
	{
		PxGeometryType::Enum GeometryType;
		PxBounds3 WorldBounds;
		PxTransform LocalPose;
		PxFilterData SimulationFilterData;
		PxFilterData QueryFilterData;
		PxReal ContactOffset;
		PxReal RestOffset;
		PxShapeFlags Flags;
		const char * Name;
		void * UserData;
		void PX_PHYSX_CORE_API getValues( const PxShape* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxShape, GeometryType, PxShapeGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxShape, WorldBounds, PxShapeGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxShape, LocalPose, PxShapeGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxShape, SimulationFilterData, PxShapeGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxShape, QueryFilterData, PxShapeGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxShape, ContactOffset, PxShapeGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxShape, RestOffset, PxShapeGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxShape, Flags, PxShapeGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxShape, Name, PxShapeGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxShape, UserData, PxShapeGeneratedValues)
	struct PxShapeGeneratedInfo

	{
		static const char* getClassName() { return "PxShape"; }
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxShape_GeometryType, PxShape, PxGeometryType::Enum > GeometryType;
		PxShapeGeometryProperty Geometry;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxShape_WorldBounds, PxShape, PxBounds3 > WorldBounds;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxShape_LocalPose, PxShape, const PxTransform &, PxTransform > LocalPose;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxShape_SimulationFilterData, PxShape, const PxFilterData &, PxFilterData > SimulationFilterData;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxShape_QueryFilterData, PxShape, const PxFilterData &, PxFilterData > QueryFilterData;
		PxShapeMaterialsProperty Materials;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxShape_ContactOffset, PxShape, PxReal, PxReal > ContactOffset;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxShape_RestOffset, PxShape, PxReal, PxReal > RestOffset;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxShape_Flags, PxShape, PxShapeFlags, PxShapeFlags > Flags;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxShape_Name, PxShape, const char *, const char * > Name;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxShape_UserData, PxShape, void *, void * > UserData;

		PX_PHYSX_CORE_API PxShapeGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxShape*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 12; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		void visitInstanceProperty( TOperator inOperator, PxU32 inPropIdx, PxU32 inStartIndex = 0 ) const
		{
			switch( inPropIdx ) {
				case 0: inOperator( GeometryType, inStartIndex + 0 );break; 
				case 1: inOperator( Geometry, inStartIndex + 1 );break; 
				case 2: inOperator( WorldBounds, inStartIndex + 2 );break; 
				case 3: inOperator( LocalPose, inStartIndex + 3 );break; 
				case 4: inOperator( SimulationFilterData, inStartIndex + 4 );break; 
				case 5: inOperator( QueryFilterData, inStartIndex + 5 );break; 
				case 6: inOperator( Materials, inStartIndex + 6 );break; 
				case 7: inOperator( ContactOffset, inStartIndex + 7 );break; 
				case 8: inOperator( RestOffset, inStartIndex + 8 );break; 
				case 9: inOperator( Flags, inStartIndex + 9 );break; 
				case 10: inOperator( Name, inStartIndex + 10 );break; 
				case 11: inOperator( UserData, inStartIndex + 11 );break; 
				default: PX_ASSERT( false ); break;
			}
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( GeometryType, inStartIndex + 0 );; 
			inOperator( Geometry, inStartIndex + 1 );; 
			inOperator( WorldBounds, inStartIndex + 2 );; 
			inOperator( LocalPose, inStartIndex + 3 );; 
			inOperator( SimulationFilterData, inStartIndex + 4 );; 
			inOperator( QueryFilterData, inStartIndex + 5 );; 
			inOperator( Materials, inStartIndex + 6 );; 
			inOperator( ContactOffset, inStartIndex + 7 );; 
			inOperator( RestOffset, inStartIndex + 8 );; 
			inOperator( Flags, inStartIndex + 9 );; 
			inOperator( Name, inStartIndex + 10 );; 
			inOperator( UserData, inStartIndex + 11 );; 
			return 12 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxShape> { PxShapeGeneratedInfo Info; };

	static PxU32ToName g_PxActorType__EnumConversion[] = {
		{ "eRIGID_STATIC", static_cast<PxU32>( PxActorType::eRIGID_STATIC ) },
		{ "eRIGID_DYNAMIC", static_cast<PxU32>( PxActorType::eRIGID_DYNAMIC ) },
		{ "ePARTICLE_SYSTEM", static_cast<PxU32>( PxActorType::ePARTICLE_SYSTEM ) },
		{ "ePARTICLE_FLUID", static_cast<PxU32>( PxActorType::ePARTICLE_FLUID ) },
		{ "eDEFORMABLE", static_cast<PxU32>( PxActorType::eDEFORMABLE ) },
		{ "eARTICULATION_LINK", static_cast<PxU32>( PxActorType::eARTICULATION_LINK ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< PxActorType::Enum > { PxEnumTraits() : NameConversion( g_PxActorType__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	static PxU32ToName g_PxActorFlag__EnumConversion[] = {
		{ "eVISUALIZATION", static_cast<PxU32>( PxActorFlag::eVISUALIZATION ) },
		{ "eDISABLE_GRAVITY", static_cast<PxU32>( PxActorFlag::eDISABLE_GRAVITY ) },
		{ "eSEND_SLEEP_NOTIFIES", static_cast<PxU32>( PxActorFlag::eSEND_SLEEP_NOTIFIES ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< PxActorFlag::Enum > { PxEnumTraits() : NameConversion( g_PxActorFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxActor;
	struct PxActorGeneratedValues
	{
		const char * ClassName;
		PxActorType::Enum Type;
		PxScene * Scene;
		const char * Name;
		PxBounds3 WorldBounds;
		PxActorFlags ActorFlags;
		PxDominanceGroup DominanceGroup;
		PxClientID OwnerClient;
		PxU32 ClientBehaviorBits;
		PxAggregate * Aggregate;
		void * UserData;
		void PX_PHYSX_CORE_API getValues( const PxActor* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxActor, ClassName, PxActorGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxActor, Type, PxActorGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxActor, Scene, PxActorGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxActor, Name, PxActorGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxActor, WorldBounds, PxActorGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxActor, ActorFlags, PxActorGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxActor, DominanceGroup, PxActorGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxActor, OwnerClient, PxActorGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxActor, ClientBehaviorBits, PxActorGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxActor, Aggregate, PxActorGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxActor, UserData, PxActorGeneratedValues)
	struct PxActorGeneratedInfo

	{
		static const char* getClassName() { return "PxActor"; }
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxActor_ClassName, PxActor, const char * > ClassName;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxActor_Type, PxActor, PxActorType::Enum > Type;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxActor_Scene, PxActor, PxScene * > Scene;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxActor_Name, PxActor, const char *, const char * > Name;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxActor_WorldBounds, PxActor, PxBounds3 > WorldBounds;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxActor_ActorFlags, PxActor, PxActorFlags, PxActorFlags > ActorFlags;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxActor_DominanceGroup, PxActor, PxDominanceGroup, PxDominanceGroup > DominanceGroup;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxActor_OwnerClient, PxActor, PxClientID, PxClientID > OwnerClient;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxActor_ClientBehaviorBits, PxActor, PxU32, PxU32 > ClientBehaviorBits;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxActor_Aggregate, PxActor, PxAggregate * > Aggregate;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxActor_UserData, PxActor, void *, void * > UserData;

		PX_PHYSX_CORE_API PxActorGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxActor*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 11; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		void visitInstanceProperty( TOperator inOperator, PxU32 inPropIdx, PxU32 inStartIndex = 0 ) const
		{
			switch( inPropIdx ) {
				case 0: inOperator( ClassName, inStartIndex + 0 );break; 
				case 1: inOperator( Type, inStartIndex + 1 );break; 
				case 2: inOperator( Scene, inStartIndex + 2 );break; 
				case 3: inOperator( Name, inStartIndex + 3 );break; 
				case 4: inOperator( WorldBounds, inStartIndex + 4 );break; 
				case 5: inOperator( ActorFlags, inStartIndex + 5 );break; 
				case 6: inOperator( DominanceGroup, inStartIndex + 6 );break; 
				case 7: inOperator( OwnerClient, inStartIndex + 7 );break; 
				case 8: inOperator( ClientBehaviorBits, inStartIndex + 8 );break; 
				case 9: inOperator( Aggregate, inStartIndex + 9 );break; 
				case 10: inOperator( UserData, inStartIndex + 10 );break; 
				default: PX_ASSERT( false ); break;
			}
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( ClassName, inStartIndex + 0 );; 
			inOperator( Type, inStartIndex + 1 );; 
			inOperator( Scene, inStartIndex + 2 );; 
			inOperator( Name, inStartIndex + 3 );; 
			inOperator( WorldBounds, inStartIndex + 4 );; 
			inOperator( ActorFlags, inStartIndex + 5 );; 
			inOperator( DominanceGroup, inStartIndex + 6 );; 
			inOperator( OwnerClient, inStartIndex + 7 );; 
			inOperator( ClientBehaviorBits, inStartIndex + 8 );; 
			inOperator( Aggregate, inStartIndex + 9 );; 
			inOperator( UserData, inStartIndex + 10 );; 
			return 11 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxActor> { PxActorGeneratedInfo Info; };

	class PxRigidActor;
	struct PxRigidActorGeneratedValues
		: PxActorGeneratedValues	{
		const char * ClassName;
		PxTransform GlobalPose;
		void PX_PHYSX_CORE_API getValues( const PxRigidActor* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRigidActor, ClassName, PxRigidActorGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRigidActor, GlobalPose, PxRigidActorGeneratedValues)
	struct PxRigidActorGeneratedInfo
		: PxActorGeneratedInfo
	{
		static const char* getClassName() { return "PxRigidActor"; }
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxRigidActor_ClassName, PxRigidActor, const char * > ClassName;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxRigidActor_GlobalPose, PxRigidActor, const PxTransform &, PxTransform > GlobalPose;
		PxRigidActorShapeCollection Shapes;
		PxReadOnlyCollectionPropertyInfo<PX_PROPERTY_INFO_NAME::PxRigidActor_Constraints, PxRigidActor, PxConstraint > Constraints;

		PX_PHYSX_CORE_API PxRigidActorGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxRigidActor*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			inOperator( *static_cast<PxActorGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxActorGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxActorGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 4; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxActorGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		void visitInstanceProperty( TOperator inOperator, PxU32 inPropIdx, PxU32 inStartIndex = 0 ) const
		{
			switch( inPropIdx ) {
				case 0: inOperator( ClassName, inStartIndex + 0 );break; 
				case 1: inOperator( GlobalPose, inStartIndex + 1 );break; 
				case 2: inOperator( Shapes, inStartIndex + 2 );break; 
				case 3: inOperator( Constraints, inStartIndex + 3 );break; 
				default: PX_ASSERT( false ); break;
			}
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( ClassName, inStartIndex + 0 );; 
			inOperator( GlobalPose, inStartIndex + 1 );; 
			inOperator( Shapes, inStartIndex + 2 );; 
			inOperator( Constraints, inStartIndex + 3 );; 
			return 4 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxRigidActor> { PxRigidActorGeneratedInfo Info; };

	class PxRigidStatic;
	struct PxRigidStaticGeneratedValues
		: PxRigidActorGeneratedValues	{
		void PX_PHYSX_CORE_API getValues( const PxRigidStatic* inSource );
	};
	struct PxRigidStaticGeneratedInfo
		: PxRigidActorGeneratedInfo
	{
		static const char* getClassName() { return "PxRigidStatic"; }

		PX_PHYSX_CORE_API PxRigidStaticGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxRigidStatic*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			inOperator( *static_cast<PxRigidActorGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxRigidActorGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxRigidActorGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 0; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxRigidActorGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		void visitInstanceProperty( TOperator inOperator, PxU32 inPropIdx, PxU32 inStartIndex = 0 ) const
		{
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			return 0 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxRigidStatic> { PxRigidStaticGeneratedInfo Info; };

	static PxU32ToName g_PxForceMode__EnumConversion[] = {
		{ "eFORCE", static_cast<PxU32>( PxForceMode::eFORCE ) },
		{ "eIMPULSE", static_cast<PxU32>( PxForceMode::eIMPULSE ) },
		{ "eVELOCITY_CHANGE", static_cast<PxU32>( PxForceMode::eVELOCITY_CHANGE ) },
		{ "eACCELERATION", static_cast<PxU32>( PxForceMode::eACCELERATION ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< PxForceMode::Enum > { PxEnumTraits() : NameConversion( g_PxForceMode__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxRigidBody;
	struct PxRigidBodyGeneratedValues
		: PxRigidActorGeneratedValues	{
		PxTransform CMassLocalPose;
		PxReal Mass;
		PxVec3 MassSpaceInertiaTensor;
		PxVec3 LinearVelocity;
		PxVec3 AngularVelocity;
		void PX_PHYSX_CORE_API getValues( const PxRigidBody* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRigidBody, CMassLocalPose, PxRigidBodyGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRigidBody, Mass, PxRigidBodyGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRigidBody, MassSpaceInertiaTensor, PxRigidBodyGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRigidBody, LinearVelocity, PxRigidBodyGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRigidBody, AngularVelocity, PxRigidBodyGeneratedValues)
	struct PxRigidBodyGeneratedInfo
		: PxRigidActorGeneratedInfo
	{
		static const char* getClassName() { return "PxRigidBody"; }
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxRigidBody_CMassLocalPose, PxRigidBody, const PxTransform &, PxTransform > CMassLocalPose;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxRigidBody_Mass, PxRigidBody, PxReal, PxReal > Mass;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxRigidBody_MassSpaceInertiaTensor, PxRigidBody, const PxVec3 &, PxVec3 > MassSpaceInertiaTensor;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxRigidBody_LinearVelocity, PxRigidBody, const PxVec3 &, PxVec3 > LinearVelocity;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxRigidBody_AngularVelocity, PxRigidBody, const PxVec3 &, PxVec3 > AngularVelocity;

		PX_PHYSX_CORE_API PxRigidBodyGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxRigidBody*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			inOperator( *static_cast<PxRigidActorGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxRigidActorGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxRigidActorGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 5; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxRigidActorGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		void visitInstanceProperty( TOperator inOperator, PxU32 inPropIdx, PxU32 inStartIndex = 0 ) const
		{
			switch( inPropIdx ) {
				case 0: inOperator( CMassLocalPose, inStartIndex + 0 );break; 
				case 1: inOperator( Mass, inStartIndex + 1 );break; 
				case 2: inOperator( MassSpaceInertiaTensor, inStartIndex + 2 );break; 
				case 3: inOperator( LinearVelocity, inStartIndex + 3 );break; 
				case 4: inOperator( AngularVelocity, inStartIndex + 4 );break; 
				default: PX_ASSERT( false ); break;
			}
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( CMassLocalPose, inStartIndex + 0 );; 
			inOperator( Mass, inStartIndex + 1 );; 
			inOperator( MassSpaceInertiaTensor, inStartIndex + 2 );; 
			inOperator( LinearVelocity, inStartIndex + 3 );; 
			inOperator( AngularVelocity, inStartIndex + 4 );; 
			return 5 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxRigidBody> { PxRigidBodyGeneratedInfo Info; };

	static PxU32ToName g_PxRigidDynamicFlag__EnumConversion[] = {
		{ "eKINEMATIC", static_cast<PxU32>( PxRigidDynamicFlag::eKINEMATIC ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< PxRigidDynamicFlag::Enum > { PxEnumTraits() : NameConversion( g_PxRigidDynamicFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxRigidDynamic;
	struct PxRigidDynamicGeneratedValues
		: PxRigidBodyGeneratedValues	{
		PxReal LinearDamping;
		PxReal AngularDamping;
		PxReal MaxAngularVelocity;
		_Bool IsSleeping;
		PxReal SleepEnergyThreshold;
		PxU32 SolverIterationCounts[2];
		PxReal ContactReportThreshold;
		PxRigidDynamicFlags RigidDynamicFlags;
		void PX_PHYSX_CORE_API getValues( const PxRigidDynamic* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRigidDynamic, LinearDamping, PxRigidDynamicGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRigidDynamic, AngularDamping, PxRigidDynamicGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRigidDynamic, MaxAngularVelocity, PxRigidDynamicGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRigidDynamic, IsSleeping, PxRigidDynamicGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRigidDynamic, SleepEnergyThreshold, PxRigidDynamicGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRigidDynamic, SolverIterationCounts, PxRigidDynamicGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRigidDynamic, ContactReportThreshold, PxRigidDynamicGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxRigidDynamic, RigidDynamicFlags, PxRigidDynamicGeneratedValues)
	struct PxRigidDynamicGeneratedInfo
		: PxRigidBodyGeneratedInfo
	{
		static const char* getClassName() { return "PxRigidDynamic"; }
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxRigidDynamic_LinearDamping, PxRigidDynamic, PxReal, PxReal > LinearDamping;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxRigidDynamic_AngularDamping, PxRigidDynamic, PxReal, PxReal > AngularDamping;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxRigidDynamic_MaxAngularVelocity, PxRigidDynamic, PxReal, PxReal > MaxAngularVelocity;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxRigidDynamic_IsSleeping, PxRigidDynamic, _Bool > IsSleeping;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxRigidDynamic_SleepEnergyThreshold, PxRigidDynamic, PxReal, PxReal > SleepEnergyThreshold;
		PxRangePropertyInfo<PX_PROPERTY_INFO_NAME::PxRigidDynamic_SolverIterationCounts, PxRigidDynamic, PxU32 > SolverIterationCounts;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxRigidDynamic_ContactReportThreshold, PxRigidDynamic, PxReal, PxReal > ContactReportThreshold;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxRigidDynamic_RigidDynamicFlags, PxRigidDynamic, PxRigidDynamicFlags, PxRigidDynamicFlags > RigidDynamicFlags;

		PX_PHYSX_CORE_API PxRigidDynamicGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxRigidDynamic*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			inOperator( *static_cast<PxRigidBodyGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxRigidBodyGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxRigidBodyGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 8; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxRigidBodyGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		void visitInstanceProperty( TOperator inOperator, PxU32 inPropIdx, PxU32 inStartIndex = 0 ) const
		{
			switch( inPropIdx ) {
				case 0: inOperator( LinearDamping, inStartIndex + 0 );break; 
				case 1: inOperator( AngularDamping, inStartIndex + 1 );break; 
				case 2: inOperator( MaxAngularVelocity, inStartIndex + 2 );break; 
				case 3: inOperator( IsSleeping, inStartIndex + 3 );break; 
				case 4: inOperator( SleepEnergyThreshold, inStartIndex + 4 );break; 
				case 5: inOperator( SolverIterationCounts, inStartIndex + 5 );break; 
				case 6: inOperator( ContactReportThreshold, inStartIndex + 6 );break; 
				case 7: inOperator( RigidDynamicFlags, inStartIndex + 7 );break; 
				default: PX_ASSERT( false ); break;
			}
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( LinearDamping, inStartIndex + 0 );; 
			inOperator( AngularDamping, inStartIndex + 1 );; 
			inOperator( MaxAngularVelocity, inStartIndex + 2 );; 
			inOperator( IsSleeping, inStartIndex + 3 );; 
			inOperator( SleepEnergyThreshold, inStartIndex + 4 );; 
			inOperator( SolverIterationCounts, inStartIndex + 5 );; 
			inOperator( ContactReportThreshold, inStartIndex + 6 );; 
			inOperator( RigidDynamicFlags, inStartIndex + 7 );; 
			return 8 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxRigidDynamic> { PxRigidDynamicGeneratedInfo Info; };

	static PxU32ToName g_PxConstraintFlag__TypeConversion[] = {
		{ "eBROKEN", static_cast<PxU32>( PxConstraintFlag::eBROKEN ) },
		{ "ePROJECTION", static_cast<PxU32>( PxConstraintFlag::ePROJECTION ) },
		{ "eCOLLISION_ENABLED", static_cast<PxU32>( PxConstraintFlag::eCOLLISION_ENABLED ) },
		{ "eREPORTING", static_cast<PxU32>( PxConstraintFlag::eREPORTING ) },
		{ "eVISUALIZATION", static_cast<PxU32>( PxConstraintFlag::eVISUALIZATION ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< PxConstraintFlag::Type > { PxEnumTraits() : NameConversion( g_PxConstraintFlag__TypeConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxConstraint;
	struct PxConstraintGeneratedValues
	{
		const char * ClassName;
		PxScene * Scene;
		PxRigidActor * Actors[2];
		PxConstraintFlags Flags;
		PxReal BreakImpulse[2];
		void PX_PHYSX_CORE_API getValues( const PxConstraint* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxConstraint, ClassName, PxConstraintGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxConstraint, Scene, PxConstraintGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxConstraint, Actors, PxConstraintGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxConstraint, Flags, PxConstraintGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxConstraint, BreakImpulse, PxConstraintGeneratedValues)
	struct PxConstraintGeneratedInfo

	{
		static const char* getClassName() { return "PxConstraint"; }
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxConstraint_ClassName, PxConstraint, const char * > ClassName;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxConstraint_Scene, PxConstraint, PxScene * > Scene;
		PxRangePropertyInfo<PX_PROPERTY_INFO_NAME::PxConstraint_Actors, PxConstraint, PxRigidActor * > Actors;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxConstraint_Flags, PxConstraint, PxConstraintFlags, PxConstraintFlags > Flags;
		PxRangePropertyInfo<PX_PROPERTY_INFO_NAME::PxConstraint_BreakImpulse, PxConstraint, PxReal > BreakImpulse;

		PX_PHYSX_CORE_API PxConstraintGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxConstraint*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 5; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		void visitInstanceProperty( TOperator inOperator, PxU32 inPropIdx, PxU32 inStartIndex = 0 ) const
		{
			switch( inPropIdx ) {
				case 0: inOperator( ClassName, inStartIndex + 0 );break; 
				case 1: inOperator( Scene, inStartIndex + 1 );break; 
				case 2: inOperator( Actors, inStartIndex + 2 );break; 
				case 3: inOperator( Flags, inStartIndex + 3 );break; 
				case 4: inOperator( BreakImpulse, inStartIndex + 4 );break; 
				default: PX_ASSERT( false ); break;
			}
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( ClassName, inStartIndex + 0 );; 
			inOperator( Scene, inStartIndex + 1 );; 
			inOperator( Actors, inStartIndex + 2 );; 
			inOperator( Flags, inStartIndex + 3 );; 
			inOperator( BreakImpulse, inStartIndex + 4 );; 
			return 5 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxConstraint> { PxConstraintGeneratedInfo Info; };

	class PxArticulation;
	struct PxArticulationGeneratedValues
	{
		PxScene * Scene;
		PxU32 MaxProjectionIterations;
		PxReal SeparationTolerance;
		PxU32 InternalDriveIterations;
		PxU32 ExternalDriveIterations;
		const char * Name;
		PxBounds3 WorldBounds;
		PxAggregate * Aggregate;
		void * UserData;
		void PX_PHYSX_CORE_API getValues( const PxArticulation* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulation, Scene, PxArticulationGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulation, MaxProjectionIterations, PxArticulationGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulation, SeparationTolerance, PxArticulationGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulation, InternalDriveIterations, PxArticulationGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulation, ExternalDriveIterations, PxArticulationGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulation, Name, PxArticulationGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulation, WorldBounds, PxArticulationGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulation, Aggregate, PxArticulationGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulation, UserData, PxArticulationGeneratedValues)
	struct PxArticulationGeneratedInfo

	{
		static const char* getClassName() { return "PxArticulation"; }
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulation_Scene, PxArticulation, PxScene * > Scene;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulation_MaxProjectionIterations, PxArticulation, PxU32, PxU32 > MaxProjectionIterations;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulation_SeparationTolerance, PxArticulation, PxReal, PxReal > SeparationTolerance;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulation_InternalDriveIterations, PxArticulation, PxU32, PxU32 > InternalDriveIterations;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulation_ExternalDriveIterations, PxArticulation, PxU32, PxU32 > ExternalDriveIterations;
		PxArticulationLinkCollectionProp Links;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulation_Name, PxArticulation, const char *, const char * > Name;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulation_WorldBounds, PxArticulation, PxBounds3 > WorldBounds;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulation_Aggregate, PxArticulation, PxAggregate * > Aggregate;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulation_UserData, PxArticulation, void *, void * > UserData;

		PX_PHYSX_CORE_API PxArticulationGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxArticulation*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 10; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		void visitInstanceProperty( TOperator inOperator, PxU32 inPropIdx, PxU32 inStartIndex = 0 ) const
		{
			switch( inPropIdx ) {
				case 0: inOperator( Scene, inStartIndex + 0 );break; 
				case 1: inOperator( MaxProjectionIterations, inStartIndex + 1 );break; 
				case 2: inOperator( SeparationTolerance, inStartIndex + 2 );break; 
				case 3: inOperator( InternalDriveIterations, inStartIndex + 3 );break; 
				case 4: inOperator( ExternalDriveIterations, inStartIndex + 4 );break; 
				case 5: inOperator( Links, inStartIndex + 5 );break; 
				case 6: inOperator( Name, inStartIndex + 6 );break; 
				case 7: inOperator( WorldBounds, inStartIndex + 7 );break; 
				case 8: inOperator( Aggregate, inStartIndex + 8 );break; 
				case 9: inOperator( UserData, inStartIndex + 9 );break; 
				default: PX_ASSERT( false ); break;
			}
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( Scene, inStartIndex + 0 );; 
			inOperator( MaxProjectionIterations, inStartIndex + 1 );; 
			inOperator( SeparationTolerance, inStartIndex + 2 );; 
			inOperator( InternalDriveIterations, inStartIndex + 3 );; 
			inOperator( ExternalDriveIterations, inStartIndex + 4 );; 
			inOperator( Links, inStartIndex + 5 );; 
			inOperator( Name, inStartIndex + 6 );; 
			inOperator( WorldBounds, inStartIndex + 7 );; 
			inOperator( Aggregate, inStartIndex + 8 );; 
			inOperator( UserData, inStartIndex + 9 );; 
			return 10 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxArticulation> { PxArticulationGeneratedInfo Info; };

	static PxU32ToName g_PxParticleBaseFlag__EnumConversion[] = {
		{ "eCOLLISION_TWOWAY", static_cast<PxU32>( PxParticleBaseFlag::eCOLLISION_TWOWAY ) },
		{ "eENABLED", static_cast<PxU32>( PxParticleBaseFlag::eENABLED ) },
		{ "ePROJECT_TO_PLANE", static_cast<PxU32>( PxParticleBaseFlag::ePROJECT_TO_PLANE ) },
		{ "ePER_PARTICLE_REST_OFFSET", static_cast<PxU32>( PxParticleBaseFlag::ePER_PARTICLE_REST_OFFSET ) },
		{ "eMINIMIZE_INDEX_REUSE_DEBUG_MODE", static_cast<PxU32>( PxParticleBaseFlag::eMINIMIZE_INDEX_REUSE_DEBUG_MODE ) },
		{ "eGPU", static_cast<PxU32>( PxParticleBaseFlag::eGPU ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< PxParticleBaseFlag::Enum > { PxEnumTraits() : NameConversion( g_PxParticleBaseFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	static PxU32ToName g_PxParticleReadDataFlag__EnumConversion[] = {
		{ "ePOSITION_BUFFER", static_cast<PxU32>( PxParticleReadDataFlag::ePOSITION_BUFFER ) },
		{ "eVELOCITY_BUFFER", static_cast<PxU32>( PxParticleReadDataFlag::eVELOCITY_BUFFER ) },
		{ "eREST_OFFSET_BUFFER", static_cast<PxU32>( PxParticleReadDataFlag::eREST_OFFSET_BUFFER ) },
		{ "eFLAGS_BUFFER", static_cast<PxU32>( PxParticleReadDataFlag::eFLAGS_BUFFER ) },
		{ "eCOLLISION_NORMAL_BUFFER", static_cast<PxU32>( PxParticleReadDataFlag::eCOLLISION_NORMAL_BUFFER ) },
		{ "eDENSITY_BUFFER", static_cast<PxU32>( PxParticleReadDataFlag::eDENSITY_BUFFER ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< PxParticleReadDataFlag::Enum > { PxEnumTraits() : NameConversion( g_PxParticleReadDataFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxParticleBase;
	struct PxParticleBaseGeneratedValues
		: PxActorGeneratedValues	{
		PxReal Damping;
		PxVec3 ExternalAcceleration;
		PxReal ParticleMass;
		PxReal Restitution;
		PxReal DynamicFriction;
		PxReal StaticFriction;
		PxFilterData SimulationFilterData;
		PxParticleBaseFlags ParticleBaseFlags;
		PxU32 MaxParticles;
		PxReal MaxMotionDistance;
		PxReal RestOffset;
		PxReal ContactOffset;
		PxReal GridSize;
		PxParticleReadDataFlags ParticleReadDataFlags;
		const PxParticleBase * IsPxParticleBase;
		PxMetaDataPlane ProjectionPlane;
		void PX_PHYSX_CORE_API getValues( const PxParticleBase* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleBase, Damping, PxParticleBaseGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleBase, ExternalAcceleration, PxParticleBaseGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleBase, ParticleMass, PxParticleBaseGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleBase, Restitution, PxParticleBaseGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleBase, DynamicFriction, PxParticleBaseGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleBase, StaticFriction, PxParticleBaseGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleBase, SimulationFilterData, PxParticleBaseGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleBase, ParticleBaseFlags, PxParticleBaseGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleBase, MaxParticles, PxParticleBaseGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleBase, MaxMotionDistance, PxParticleBaseGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleBase, RestOffset, PxParticleBaseGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleBase, ContactOffset, PxParticleBaseGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleBase, GridSize, PxParticleBaseGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleBase, ParticleReadDataFlags, PxParticleBaseGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleBase, IsPxParticleBase, PxParticleBaseGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleBase, ProjectionPlane, PxParticleBaseGeneratedValues)
	struct PxParticleBaseGeneratedInfo
		: PxActorGeneratedInfo
	{
		static const char* getClassName() { return "PxParticleBase"; }
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleBase_Damping, PxParticleBase, PxReal, PxReal > Damping;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleBase_ExternalAcceleration, PxParticleBase, const PxVec3 &, PxVec3 > ExternalAcceleration;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleBase_ParticleMass, PxParticleBase, PxReal, PxReal > ParticleMass;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleBase_Restitution, PxParticleBase, PxReal, PxReal > Restitution;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleBase_DynamicFriction, PxParticleBase, PxReal, PxReal > DynamicFriction;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleBase_StaticFriction, PxParticleBase, PxReal, PxReal > StaticFriction;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleBase_SimulationFilterData, PxParticleBase, const PxFilterData &, PxFilterData > SimulationFilterData;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleBase_ParticleBaseFlags, PxParticleBase, PxParticleBaseFlags > ParticleBaseFlags;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleBase_MaxParticles, PxParticleBase, PxU32 > MaxParticles;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleBase_MaxMotionDistance, PxParticleBase, PxReal > MaxMotionDistance;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleBase_RestOffset, PxParticleBase, PxReal > RestOffset;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleBase_ContactOffset, PxParticleBase, PxReal > ContactOffset;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleBase_GridSize, PxParticleBase, PxReal > GridSize;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleBase_ParticleReadDataFlags, PxParticleBase, PxParticleReadDataFlags > ParticleReadDataFlags;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleBase_IsPxParticleBase, PxParticleBase, const PxParticleBase * > IsPxParticleBase;
		ProjectionPlaneProperty ProjectionPlane;

		PX_PHYSX_CORE_API PxParticleBaseGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxParticleBase*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			inOperator( *static_cast<PxActorGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxActorGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxActorGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 16; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxActorGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		void visitInstanceProperty( TOperator inOperator, PxU32 inPropIdx, PxU32 inStartIndex = 0 ) const
		{
			switch( inPropIdx ) {
				case 0: inOperator( Damping, inStartIndex + 0 );break; 
				case 1: inOperator( ExternalAcceleration, inStartIndex + 1 );break; 
				case 2: inOperator( ParticleMass, inStartIndex + 2 );break; 
				case 3: inOperator( Restitution, inStartIndex + 3 );break; 
				case 4: inOperator( DynamicFriction, inStartIndex + 4 );break; 
				case 5: inOperator( StaticFriction, inStartIndex + 5 );break; 
				case 6: inOperator( SimulationFilterData, inStartIndex + 6 );break; 
				case 7: inOperator( ParticleBaseFlags, inStartIndex + 7 );break; 
				case 8: inOperator( MaxParticles, inStartIndex + 8 );break; 
				case 9: inOperator( MaxMotionDistance, inStartIndex + 9 );break; 
				case 10: inOperator( RestOffset, inStartIndex + 10 );break; 
				case 11: inOperator( ContactOffset, inStartIndex + 11 );break; 
				case 12: inOperator( GridSize, inStartIndex + 12 );break; 
				case 13: inOperator( ParticleReadDataFlags, inStartIndex + 13 );break; 
				case 14: inOperator( IsPxParticleBase, inStartIndex + 14 );break; 
				case 15: inOperator( ProjectionPlane, inStartIndex + 15 );break; 
				default: PX_ASSERT( false ); break;
			}
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( Damping, inStartIndex + 0 );; 
			inOperator( ExternalAcceleration, inStartIndex + 1 );; 
			inOperator( ParticleMass, inStartIndex + 2 );; 
			inOperator( Restitution, inStartIndex + 3 );; 
			inOperator( DynamicFriction, inStartIndex + 4 );; 
			inOperator( StaticFriction, inStartIndex + 5 );; 
			inOperator( SimulationFilterData, inStartIndex + 6 );; 
			inOperator( ParticleBaseFlags, inStartIndex + 7 );; 
			inOperator( MaxParticles, inStartIndex + 8 );; 
			inOperator( MaxMotionDistance, inStartIndex + 9 );; 
			inOperator( RestOffset, inStartIndex + 10 );; 
			inOperator( ContactOffset, inStartIndex + 11 );; 
			inOperator( GridSize, inStartIndex + 12 );; 
			inOperator( ParticleReadDataFlags, inStartIndex + 13 );; 
			inOperator( IsPxParticleBase, inStartIndex + 14 );; 
			inOperator( ProjectionPlane, inStartIndex + 15 );; 
			return 16 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxParticleBase> { PxParticleBaseGeneratedInfo Info; };

	class PxParticleSystem;
	struct PxParticleSystemGeneratedValues
		: PxParticleBaseGeneratedValues	{
		void PX_PHYSX_CORE_API getValues( const PxParticleSystem* inSource );
	};
	struct PxParticleSystemGeneratedInfo
		: PxParticleBaseGeneratedInfo
	{
		static const char* getClassName() { return "PxParticleSystem"; }

		PX_PHYSX_CORE_API PxParticleSystemGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxParticleSystem*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			inOperator( *static_cast<PxParticleBaseGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxParticleBaseGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxParticleBaseGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 0; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxParticleBaseGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		void visitInstanceProperty( TOperator inOperator, PxU32 inPropIdx, PxU32 inStartIndex = 0 ) const
		{
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			return 0 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxParticleSystem> { PxParticleSystemGeneratedInfo Info; };

	class PxParticleFluid;
	struct PxParticleFluidGeneratedValues
		: PxParticleBaseGeneratedValues	{
		PxReal Stiffness;
		PxReal Viscosity;
		PxReal RestParticleDistance;
		void PX_PHYSX_CORE_API getValues( const PxParticleFluid* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleFluid, Stiffness, PxParticleFluidGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleFluid, Viscosity, PxParticleFluidGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleFluid, RestParticleDistance, PxParticleFluidGeneratedValues)
	struct PxParticleFluidGeneratedInfo
		: PxParticleBaseGeneratedInfo
	{
		static const char* getClassName() { return "PxParticleFluid"; }
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleFluid_Stiffness, PxParticleFluid, PxReal, PxReal > Stiffness;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleFluid_Viscosity, PxParticleFluid, PxReal, PxReal > Viscosity;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleFluid_RestParticleDistance, PxParticleFluid, PxReal > RestParticleDistance;

		PX_PHYSX_CORE_API PxParticleFluidGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxParticleFluid*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			inOperator( *static_cast<PxParticleBaseGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxParticleBaseGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxParticleBaseGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 3; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxParticleBaseGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		void visitInstanceProperty( TOperator inOperator, PxU32 inPropIdx, PxU32 inStartIndex = 0 ) const
		{
			switch( inPropIdx ) {
				case 0: inOperator( Stiffness, inStartIndex + 0 );break; 
				case 1: inOperator( Viscosity, inStartIndex + 1 );break; 
				case 2: inOperator( RestParticleDistance, inStartIndex + 2 );break; 
				default: PX_ASSERT( false ); break;
			}
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( Stiffness, inStartIndex + 0 );; 
			inOperator( Viscosity, inStartIndex + 1 );; 
			inOperator( RestParticleDistance, inStartIndex + 2 );; 
			return 3 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxParticleFluid> { PxParticleFluidGeneratedInfo Info; };

	static PxU32ToName g_PxDeformableFlag__EnumConversion[] = {
		{ "ePRESSURE", static_cast<PxU32>( PxDeformableFlag::ePRESSURE ) },
		{ "eSTATIC", static_cast<PxU32>( PxDeformableFlag::eSTATIC ) },
		{ "eSELFCOLLISION", static_cast<PxU32>( PxDeformableFlag::eSELFCOLLISION ) },
		{ "eBENDING", static_cast<PxU32>( PxDeformableFlag::eBENDING ) },
		{ "eVOLUME_CONSERVATION", static_cast<PxU32>( PxDeformableFlag::eVOLUME_CONSERVATION ) },
		{ "eDAMPING", static_cast<PxU32>( PxDeformableFlag::eDAMPING ) },
		{ "eSURFACE_COLLISION", static_cast<PxU32>( PxDeformableFlag::eSURFACE_COLLISION ) },
		{ "eTEARABLE", static_cast<PxU32>( PxDeformableFlag::eTEARABLE ) },
		{ "eCOMDAMPING", static_cast<PxU32>( PxDeformableFlag::eCOMDAMPING ) },
		{ "eVALIDBOUNDS", static_cast<PxU32>( PxDeformableFlag::eVALIDBOUNDS ) },
		{ "eBULK_DATA_DOUBLE_BUFFERING", static_cast<PxU32>( PxDeformableFlag::eBULK_DATA_DOUBLE_BUFFERING ) },
		{ "eTWOWAY", static_cast<PxU32>( PxDeformableFlag::eTWOWAY ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< PxDeformableFlag::Enum > { PxEnumTraits() : NameConversion( g_PxDeformableFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxDeformable;
	struct PxDeformableGeneratedValues
		: PxActorGeneratedValues	{
		PxDeformableMesh * DeformableMesh;
		PxReal BendingStiffness;
		PxReal VolumeStiffness;
		PxReal StretchingStiffness;
		PxReal DampingCoefficient;
		PxReal StaticFriction;
		PxReal DynamicFriction;
		PxReal Pressure;
		PxReal TearFactor;
		PxReal AttachmentTearFactor;
		PxReal Mass;
		PxReal RelativeGridSpacing;
		PxU32 SolverIterations;
		PxU32 HierarchicalSolverIterations;
		PxBounds3 WorldBounds;
		PxBounds3 ValidBounds;
		PxU32 NumVertices;
		PxU32 MaxVertices;
		PxReal CollisionStiffness;
		PxReal AttachmentStiffness;
		PxReal ContactOffset;
		PxReal RestOffset;
		PxReal PenetrationOffset;
		PxReal SelfCollisionOffset;
		PxVec3 ExternalAcceleration;
		PxVec3 WindAcceleration;
		_Bool IsSleeping;
		PxReal SleepLinearVelocity;
		PxFilterData SimulationFilterData;
		PxU32 DeformableFlags;
		PxU32 DeformableReadDataFlags;
		void PX_PHYSX_CORE_API getValues( const PxDeformable* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxDeformable, DeformableMesh, PxDeformableGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxDeformable, BendingStiffness, PxDeformableGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxDeformable, VolumeStiffness, PxDeformableGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxDeformable, StretchingStiffness, PxDeformableGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxDeformable, DampingCoefficient, PxDeformableGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxDeformable, StaticFriction, PxDeformableGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxDeformable, DynamicFriction, PxDeformableGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxDeformable, Pressure, PxDeformableGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxDeformable, TearFactor, PxDeformableGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxDeformable, AttachmentTearFactor, PxDeformableGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxDeformable, Mass, PxDeformableGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxDeformable, RelativeGridSpacing, PxDeformableGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxDeformable, SolverIterations, PxDeformableGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxDeformable, HierarchicalSolverIterations, PxDeformableGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxDeformable, WorldBounds, PxDeformableGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxDeformable, ValidBounds, PxDeformableGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxDeformable, NumVertices, PxDeformableGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxDeformable, MaxVertices, PxDeformableGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxDeformable, CollisionStiffness, PxDeformableGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxDeformable, AttachmentStiffness, PxDeformableGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxDeformable, ContactOffset, PxDeformableGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxDeformable, RestOffset, PxDeformableGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxDeformable, PenetrationOffset, PxDeformableGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxDeformable, SelfCollisionOffset, PxDeformableGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxDeformable, ExternalAcceleration, PxDeformableGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxDeformable, WindAcceleration, PxDeformableGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxDeformable, IsSleeping, PxDeformableGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxDeformable, SleepLinearVelocity, PxDeformableGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxDeformable, SimulationFilterData, PxDeformableGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxDeformable, DeformableFlags, PxDeformableGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxDeformable, DeformableReadDataFlags, PxDeformableGeneratedValues)
	struct PxDeformableGeneratedInfo
		: PxActorGeneratedInfo
	{
		static const char* getClassName() { return "PxDeformable"; }
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxDeformable_DeformableMesh, PxDeformable, PxDeformableMesh * > DeformableMesh;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxDeformable_BendingStiffness, PxDeformable, PxReal, PxReal > BendingStiffness;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxDeformable_VolumeStiffness, PxDeformable, PxReal, PxReal > VolumeStiffness;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxDeformable_StretchingStiffness, PxDeformable, PxReal, PxReal > StretchingStiffness;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxDeformable_DampingCoefficient, PxDeformable, PxReal, PxReal > DampingCoefficient;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxDeformable_StaticFriction, PxDeformable, PxReal, PxReal > StaticFriction;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxDeformable_DynamicFriction, PxDeformable, PxReal, PxReal > DynamicFriction;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxDeformable_Pressure, PxDeformable, PxReal, PxReal > Pressure;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxDeformable_TearFactor, PxDeformable, PxReal, PxReal > TearFactor;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxDeformable_AttachmentTearFactor, PxDeformable, PxReal, PxReal > AttachmentTearFactor;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxDeformable_Mass, PxDeformable, PxReal > Mass;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxDeformable_RelativeGridSpacing, PxDeformable, PxReal > RelativeGridSpacing;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxDeformable_SolverIterations, PxDeformable, PxU32, PxU32 > SolverIterations;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxDeformable_HierarchicalSolverIterations, PxDeformable, PxU32, PxU32 > HierarchicalSolverIterations;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxDeformable_WorldBounds, PxDeformable, PxBounds3 > WorldBounds;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxDeformable_ValidBounds, PxDeformable, const PxBounds3 &, PxBounds3 > ValidBounds;
		PxWriteOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxDeformable_ConstrainPositions, PxDeformable, const PxStrideIterator<const PxVec3> & > ConstrainPositions;
		PxWriteOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxDeformable_ConstrainNormals, PxDeformable, const PxStrideIterator<const PxVec3> & > ConstrainNormals;
		PxWriteOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxDeformable_ConstrainCoefficients, PxDeformable, const PxStrideIterator<const PxDeformableConstrainCoefficients> & > ConstrainCoefficients;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxDeformable_NumVertices, PxDeformable, PxU32 > NumVertices;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxDeformable_MaxVertices, PxDeformable, PxU32 > MaxVertices;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxDeformable_CollisionStiffness, PxDeformable, PxReal, PxReal > CollisionStiffness;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxDeformable_AttachmentStiffness, PxDeformable, PxReal, PxReal > AttachmentStiffness;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxDeformable_ContactOffset, PxDeformable, PxReal, PxReal > ContactOffset;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxDeformable_RestOffset, PxDeformable, PxReal, PxReal > RestOffset;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxDeformable_PenetrationOffset, PxDeformable, PxReal, PxReal > PenetrationOffset;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxDeformable_SelfCollisionOffset, PxDeformable, PxReal, PxReal > SelfCollisionOffset;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxDeformable_ExternalAcceleration, PxDeformable, PxVec3, PxVec3 > ExternalAcceleration;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxDeformable_WindAcceleration, PxDeformable, PxVec3, PxVec3 > WindAcceleration;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxDeformable_IsSleeping, PxDeformable, _Bool > IsSleeping;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxDeformable_SleepLinearVelocity, PxDeformable, PxReal, PxReal > SleepLinearVelocity;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxDeformable_SimulationFilterData, PxDeformable, const PxFilterData &, PxFilterData > SimulationFilterData;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxDeformable_DeformableFlags, PxDeformable, PxU32 > DeformableFlags;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxDeformable_DeformableReadDataFlags, PxDeformable, PxU32 > DeformableReadDataFlags;

		PX_PHYSX_CORE_API PxDeformableGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxDeformable*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			inOperator( *static_cast<PxActorGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxActorGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxActorGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 34; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxActorGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		void visitInstanceProperty( TOperator inOperator, PxU32 inPropIdx, PxU32 inStartIndex = 0 ) const
		{
			switch( inPropIdx ) {
				case 0: inOperator( DeformableMesh, inStartIndex + 0 );break; 
				case 1: inOperator( BendingStiffness, inStartIndex + 1 );break; 
				case 2: inOperator( VolumeStiffness, inStartIndex + 2 );break; 
				case 3: inOperator( StretchingStiffness, inStartIndex + 3 );break; 
				case 4: inOperator( DampingCoefficient, inStartIndex + 4 );break; 
				case 5: inOperator( StaticFriction, inStartIndex + 5 );break; 
				case 6: inOperator( DynamicFriction, inStartIndex + 6 );break; 
				case 7: inOperator( Pressure, inStartIndex + 7 );break; 
				case 8: inOperator( TearFactor, inStartIndex + 8 );break; 
				case 9: inOperator( AttachmentTearFactor, inStartIndex + 9 );break; 
				case 10: inOperator( Mass, inStartIndex + 10 );break; 
				case 11: inOperator( RelativeGridSpacing, inStartIndex + 11 );break; 
				case 12: inOperator( SolverIterations, inStartIndex + 12 );break; 
				case 13: inOperator( HierarchicalSolverIterations, inStartIndex + 13 );break; 
				case 14: inOperator( WorldBounds, inStartIndex + 14 );break; 
				case 15: inOperator( ValidBounds, inStartIndex + 15 );break; 
				case 16: inOperator( ConstrainPositions, inStartIndex + 16 );break; 
				case 17: inOperator( ConstrainNormals, inStartIndex + 17 );break; 
				case 18: inOperator( ConstrainCoefficients, inStartIndex + 18 );break; 
				case 19: inOperator( NumVertices, inStartIndex + 19 );break; 
				case 20: inOperator( MaxVertices, inStartIndex + 20 );break; 
				case 21: inOperator( CollisionStiffness, inStartIndex + 21 );break; 
				case 22: inOperator( AttachmentStiffness, inStartIndex + 22 );break; 
				case 23: inOperator( ContactOffset, inStartIndex + 23 );break; 
				case 24: inOperator( RestOffset, inStartIndex + 24 );break; 
				case 25: inOperator( PenetrationOffset, inStartIndex + 25 );break; 
				case 26: inOperator( SelfCollisionOffset, inStartIndex + 26 );break; 
				case 27: inOperator( ExternalAcceleration, inStartIndex + 27 );break; 
				case 28: inOperator( WindAcceleration, inStartIndex + 28 );break; 
				case 29: inOperator( IsSleeping, inStartIndex + 29 );break; 
				case 30: inOperator( SleepLinearVelocity, inStartIndex + 30 );break; 
				case 31: inOperator( SimulationFilterData, inStartIndex + 31 );break; 
				case 32: inOperator( DeformableFlags, inStartIndex + 32 );break; 
				case 33: inOperator( DeformableReadDataFlags, inStartIndex + 33 );break; 
				default: PX_ASSERT( false ); break;
			}
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( DeformableMesh, inStartIndex + 0 );; 
			inOperator( BendingStiffness, inStartIndex + 1 );; 
			inOperator( VolumeStiffness, inStartIndex + 2 );; 
			inOperator( StretchingStiffness, inStartIndex + 3 );; 
			inOperator( DampingCoefficient, inStartIndex + 4 );; 
			inOperator( StaticFriction, inStartIndex + 5 );; 
			inOperator( DynamicFriction, inStartIndex + 6 );; 
			inOperator( Pressure, inStartIndex + 7 );; 
			inOperator( TearFactor, inStartIndex + 8 );; 
			inOperator( AttachmentTearFactor, inStartIndex + 9 );; 
			inOperator( Mass, inStartIndex + 10 );; 
			inOperator( RelativeGridSpacing, inStartIndex + 11 );; 
			inOperator( SolverIterations, inStartIndex + 12 );; 
			inOperator( HierarchicalSolverIterations, inStartIndex + 13 );; 
			inOperator( WorldBounds, inStartIndex + 14 );; 
			inOperator( ValidBounds, inStartIndex + 15 );; 
			inOperator( ConstrainPositions, inStartIndex + 16 );; 
			inOperator( ConstrainNormals, inStartIndex + 17 );; 
			inOperator( ConstrainCoefficients, inStartIndex + 18 );; 
			inOperator( NumVertices, inStartIndex + 19 );; 
			inOperator( MaxVertices, inStartIndex + 20 );; 
			inOperator( CollisionStiffness, inStartIndex + 21 );; 
			inOperator( AttachmentStiffness, inStartIndex + 22 );; 
			inOperator( ContactOffset, inStartIndex + 23 );; 
			inOperator( RestOffset, inStartIndex + 24 );; 
			inOperator( PenetrationOffset, inStartIndex + 25 );; 
			inOperator( SelfCollisionOffset, inStartIndex + 26 );; 
			inOperator( ExternalAcceleration, inStartIndex + 27 );; 
			inOperator( WindAcceleration, inStartIndex + 28 );; 
			inOperator( IsSleeping, inStartIndex + 29 );; 
			inOperator( SleepLinearVelocity, inStartIndex + 30 );; 
			inOperator( SimulationFilterData, inStartIndex + 31 );; 
			inOperator( DeformableFlags, inStartIndex + 32 );; 
			inOperator( DeformableReadDataFlags, inStartIndex + 33 );; 
			return 34 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxDeformable> { PxDeformableGeneratedInfo Info; };

	static PxU32ToName g_PxMaterialFlag__EnumConversion[] = {
		{ "eANISOTROPIC", static_cast<PxU32>( PxMaterialFlag::eANISOTROPIC ) },
		{ "eDISABLE_FRICTION", static_cast<PxU32>( PxMaterialFlag::eDISABLE_FRICTION ) },
		{ "eDISABLE_STRONG_FRICTION", static_cast<PxU32>( PxMaterialFlag::eDISABLE_STRONG_FRICTION ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< PxMaterialFlag::Enum > { PxEnumTraits() : NameConversion( g_PxMaterialFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	static PxU32ToName g_PxCombineMode__EnumConversion[] = {
		{ "eAVERAGE", static_cast<PxU32>( PxCombineMode::eAVERAGE ) },
		{ "eMIN", static_cast<PxU32>( PxCombineMode::eMIN ) },
		{ "eMULTIPLY", static_cast<PxU32>( PxCombineMode::eMULTIPLY ) },
		{ "eMAX", static_cast<PxU32>( PxCombineMode::eMAX ) },
		{ "eN_VALUES", static_cast<PxU32>( PxCombineMode::eN_VALUES ) },
		{ "ePAD_32", static_cast<PxU32>( PxCombineMode::ePAD_32 ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< PxCombineMode::Enum > { PxEnumTraits() : NameConversion( g_PxCombineMode__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxMaterial;
	struct PxMaterialGeneratedValues
	{
		PxReal DynamicFriction;
		PxReal StaticFriction;
		PxReal Restitution;
		PxReal DynamicFrictionV;
		PxReal StaticFrictionV;
		PxVec3 DirOfAnisotropy;
		PxMaterialFlags Flags;
		PxCombineMode::Enum FrictionCombineMode;
		PxCombineMode::Enum RestitutionCombineMode;
		void * UserData;
		void PX_PHYSX_CORE_API getValues( const PxMaterial* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxMaterial, DynamicFriction, PxMaterialGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxMaterial, StaticFriction, PxMaterialGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxMaterial, Restitution, PxMaterialGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxMaterial, DynamicFrictionV, PxMaterialGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxMaterial, StaticFrictionV, PxMaterialGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxMaterial, DirOfAnisotropy, PxMaterialGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxMaterial, Flags, PxMaterialGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxMaterial, FrictionCombineMode, PxMaterialGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxMaterial, RestitutionCombineMode, PxMaterialGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxMaterial, UserData, PxMaterialGeneratedValues)
	struct PxMaterialGeneratedInfo

	{
		static const char* getClassName() { return "PxMaterial"; }
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxMaterial_DynamicFriction, PxMaterial, PxReal, PxReal > DynamicFriction;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxMaterial_StaticFriction, PxMaterial, PxReal, PxReal > StaticFriction;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxMaterial_Restitution, PxMaterial, PxReal, PxReal > Restitution;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxMaterial_DynamicFrictionV, PxMaterial, PxReal, PxReal > DynamicFrictionV;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxMaterial_StaticFrictionV, PxMaterial, PxReal, PxReal > StaticFrictionV;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxMaterial_DirOfAnisotropy, PxMaterial, const PxVec3 &, PxVec3 > DirOfAnisotropy;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxMaterial_Flags, PxMaterial, PxMaterialFlags, PxMaterialFlags > Flags;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxMaterial_FrictionCombineMode, PxMaterial, PxCombineMode::Enum, PxCombineMode::Enum > FrictionCombineMode;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxMaterial_RestitutionCombineMode, PxMaterial, PxCombineMode::Enum, PxCombineMode::Enum > RestitutionCombineMode;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxMaterial_UserData, PxMaterial, void *, void * > UserData;

		PX_PHYSX_CORE_API PxMaterialGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxMaterial*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 10; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		void visitInstanceProperty( TOperator inOperator, PxU32 inPropIdx, PxU32 inStartIndex = 0 ) const
		{
			switch( inPropIdx ) {
				case 0: inOperator( DynamicFriction, inStartIndex + 0 );break; 
				case 1: inOperator( StaticFriction, inStartIndex + 1 );break; 
				case 2: inOperator( Restitution, inStartIndex + 2 );break; 
				case 3: inOperator( DynamicFrictionV, inStartIndex + 3 );break; 
				case 4: inOperator( StaticFrictionV, inStartIndex + 4 );break; 
				case 5: inOperator( DirOfAnisotropy, inStartIndex + 5 );break; 
				case 6: inOperator( Flags, inStartIndex + 6 );break; 
				case 7: inOperator( FrictionCombineMode, inStartIndex + 7 );break; 
				case 8: inOperator( RestitutionCombineMode, inStartIndex + 8 );break; 
				case 9: inOperator( UserData, inStartIndex + 9 );break; 
				default: PX_ASSERT( false ); break;
			}
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( DynamicFriction, inStartIndex + 0 );; 
			inOperator( StaticFriction, inStartIndex + 1 );; 
			inOperator( Restitution, inStartIndex + 2 );; 
			inOperator( DynamicFrictionV, inStartIndex + 3 );; 
			inOperator( StaticFrictionV, inStartIndex + 4 );; 
			inOperator( DirOfAnisotropy, inStartIndex + 5 );; 
			inOperator( Flags, inStartIndex + 6 );; 
			inOperator( FrictionCombineMode, inStartIndex + 7 );; 
			inOperator( RestitutionCombineMode, inStartIndex + 8 );; 
			inOperator( UserData, inStartIndex + 9 );; 
			return 10 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxMaterial> { PxMaterialGeneratedInfo Info; };

	static PxU32ToName g_PxSceneFlag__EnumConversion[] = {
		{ "eDISABLE_SSE", static_cast<PxU32>( PxSceneFlag::eDISABLE_SSE ) },
		{ "eENABLE_ACTIVETRANSFORMS", static_cast<PxU32>( PxSceneFlag::eENABLE_ACTIVETRANSFORMS ) },
		{ "eENABLE_SWEPT_INTEGRATION", static_cast<PxU32>( PxSceneFlag::eENABLE_SWEPT_INTEGRATION ) },
		{ "eADAPTIVE_FORCE", static_cast<PxU32>( PxSceneFlag::eADAPTIVE_FORCE ) },
		{ "eENABLE_KINEMATIC_STATIC_PAIRS", static_cast<PxU32>( PxSceneFlag::eENABLE_KINEMATIC_STATIC_PAIRS ) },
		{ "eENABLE_KINEMATIC_PAIRS", static_cast<PxU32>( PxSceneFlag::eENABLE_KINEMATIC_PAIRS ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< PxSceneFlag::Enum > { PxEnumTraits() : NameConversion( g_PxSceneFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	static PxU32ToName g_PxActorTypeSelectionFlag__EnumConversion[] = {
		{ "eRIGID_STATIC", static_cast<PxU32>( PxActorTypeSelectionFlag::eRIGID_STATIC ) },
		{ "eRIGID_DYNAMIC", static_cast<PxU32>( PxActorTypeSelectionFlag::eRIGID_DYNAMIC ) },
		{ "ePARTICLE_SYSTEM", static_cast<PxU32>( PxActorTypeSelectionFlag::ePARTICLE_SYSTEM ) },
		{ "ePARTICLE_FLUID", static_cast<PxU32>( PxActorTypeSelectionFlag::ePARTICLE_FLUID ) },
		{ "eDEFORMABLE", static_cast<PxU32>( PxActorTypeSelectionFlag::eDEFORMABLE ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< PxActorTypeSelectionFlag::Enum > { PxEnumTraits() : NameConversion( g_PxActorTypeSelectionFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	static PxU32ToName g_PxVisualizationParameter__EnumConversion[] = {
		{ "eSCALE", static_cast<PxU32>( PxVisualizationParameter::eSCALE ) },
		{ "eWORLD_AXES", static_cast<PxU32>( PxVisualizationParameter::eWORLD_AXES ) },
		{ "eBODY_AXES", static_cast<PxU32>( PxVisualizationParameter::eBODY_AXES ) },
		{ "eBODY_MASS_AXES", static_cast<PxU32>( PxVisualizationParameter::eBODY_MASS_AXES ) },
		{ "eBODY_LIN_VELOCITY", static_cast<PxU32>( PxVisualizationParameter::eBODY_LIN_VELOCITY ) },
		{ "eBODY_ANG_VELOCITY", static_cast<PxU32>( PxVisualizationParameter::eBODY_ANG_VELOCITY ) },
		{ "eBODY_JOINT_GROUPS", static_cast<PxU32>( PxVisualizationParameter::eBODY_JOINT_GROUPS ) },
		{ "eCONTACT_POINT", static_cast<PxU32>( PxVisualizationParameter::eCONTACT_POINT ) },
		{ "eCONTACT_NORMAL", static_cast<PxU32>( PxVisualizationParameter::eCONTACT_NORMAL ) },
		{ "eCONTACT_ERROR", static_cast<PxU32>( PxVisualizationParameter::eCONTACT_ERROR ) },
		{ "eCONTACT_FORCE", static_cast<PxU32>( PxVisualizationParameter::eCONTACT_FORCE ) },
		{ "eACTOR_AXES", static_cast<PxU32>( PxVisualizationParameter::eACTOR_AXES ) },
		{ "eCOLLISION_AABBS", static_cast<PxU32>( PxVisualizationParameter::eCOLLISION_AABBS ) },
		{ "eCOLLISION_SHAPES", static_cast<PxU32>( PxVisualizationParameter::eCOLLISION_SHAPES ) },
		{ "eCOLLISION_AXES", static_cast<PxU32>( PxVisualizationParameter::eCOLLISION_AXES ) },
		{ "eCOLLISION_COMPOUNDS", static_cast<PxU32>( PxVisualizationParameter::eCOLLISION_COMPOUNDS ) },
		{ "eCOLLISION_FNORMALS", static_cast<PxU32>( PxVisualizationParameter::eCOLLISION_FNORMALS ) },
		{ "eCOLLISION_EDGES", static_cast<PxU32>( PxVisualizationParameter::eCOLLISION_EDGES ) },
		{ "eCOLLISION_STATIC", static_cast<PxU32>( PxVisualizationParameter::eCOLLISION_STATIC ) },
		{ "eCOLLISION_DYNAMIC", static_cast<PxU32>( PxVisualizationParameter::eCOLLISION_DYNAMIC ) },
		{ "eCOLLISION_CONVEX_PARTS", static_cast<PxU32>( PxVisualizationParameter::eCOLLISION_CONVEX_PARTS ) },
		{ "eCOLLISION_PAIRS", static_cast<PxU32>( PxVisualizationParameter::eCOLLISION_PAIRS ) },
		{ "eJOINT_LOCAL_FRAMES", static_cast<PxU32>( PxVisualizationParameter::eJOINT_LOCAL_FRAMES ) },
		{ "eJOINT_LIMITS", static_cast<PxU32>( PxVisualizationParameter::eJOINT_LIMITS ) },
		{ "ePARTICLE_SYSTEM_POSITION", static_cast<PxU32>( PxVisualizationParameter::ePARTICLE_SYSTEM_POSITION ) },
		{ "ePARTICLE_SYSTEM_VELOCITY", static_cast<PxU32>( PxVisualizationParameter::ePARTICLE_SYSTEM_VELOCITY ) },
		{ "ePARTICLE_SYSTEM_COLLISION_NORMAL", static_cast<PxU32>( PxVisualizationParameter::ePARTICLE_SYSTEM_COLLISION_NORMAL ) },
		{ "ePARTICLE_SYSTEM_BOUNDS", static_cast<PxU32>( PxVisualizationParameter::ePARTICLE_SYSTEM_BOUNDS ) },
		{ "ePARTICLE_SYSTEM_GRID", static_cast<PxU32>( PxVisualizationParameter::ePARTICLE_SYSTEM_GRID ) },
		{ "ePARTICLE_SYSTEM_BROADPHASE_BOUNDS", static_cast<PxU32>( PxVisualizationParameter::ePARTICLE_SYSTEM_BROADPHASE_BOUNDS ) },
		{ "ePARTICLE_SYSTEM_MAX_MOTION_DISTANCE", static_cast<PxU32>( PxVisualizationParameter::ePARTICLE_SYSTEM_MAX_MOTION_DISTANCE ) },
		{ "ePARTICLE_SYSTEM_DRAINS", static_cast<PxU32>( PxVisualizationParameter::ePARTICLE_SYSTEM_DRAINS ) },
		{ "eDEFORMABLE_MESH", static_cast<PxU32>( PxVisualizationParameter::eDEFORMABLE_MESH ) },
		{ "eDEFORMABLE_ATTACHMENTS", static_cast<PxU32>( PxVisualizationParameter::eDEFORMABLE_ATTACHMENTS ) },
		{ "eDEFORMABLE_COLLISIONS", static_cast<PxU32>( PxVisualizationParameter::eDEFORMABLE_COLLISIONS ) },
		{ "eDEFORMABLE_SELFCOLLISIONS", static_cast<PxU32>( PxVisualizationParameter::eDEFORMABLE_SELFCOLLISIONS ) },
		{ "eDEFORMABLE_SLEEP", static_cast<PxU32>( PxVisualizationParameter::eDEFORMABLE_SLEEP ) },
		{ "eDEFORMABLE_TEARING", static_cast<PxU32>( PxVisualizationParameter::eDEFORMABLE_TEARING ) },
		{ "eDEFORMABLE_VALIDBOUNDS", static_cast<PxU32>( PxVisualizationParameter::eDEFORMABLE_VALIDBOUNDS ) },
		{ "eDEFORMABLE_SHAPES", static_cast<PxU32>( PxVisualizationParameter::eDEFORMABLE_SHAPES ) },
		{ "eCULL_BOX", static_cast<PxU32>( PxVisualizationParameter::eCULL_BOX ) },
		{ "eNUM_VALUES", static_cast<PxU32>( PxVisualizationParameter::eNUM_VALUES ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< PxVisualizationParameter::Enum > { PxEnumTraits() : NameConversion( g_PxVisualizationParameter__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	static PxU32ToName g_PxSceneQueryFlag__EnumConversion[] = {
		{ "eIMPACT", static_cast<PxU32>( PxSceneQueryFlag::eIMPACT ) },
		{ "eNORMAL", static_cast<PxU32>( PxSceneQueryFlag::eNORMAL ) },
		{ "eDISTANCE", static_cast<PxU32>( PxSceneQueryFlag::eDISTANCE ) },
		{ "eUV", static_cast<PxU32>( PxSceneQueryFlag::eUV ) },
		{ "eINITIAL_OVERLAP", static_cast<PxU32>( PxSceneQueryFlag::eINITIAL_OVERLAP ) },
		{ "eTOUCHING_HIT", static_cast<PxU32>( PxSceneQueryFlag::eTOUCHING_HIT ) },
		{ "eBLOCKING_HIT", static_cast<PxU32>( PxSceneQueryFlag::eBLOCKING_HIT ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< PxSceneQueryFlag::Enum > { PxEnumTraits() : NameConversion( g_PxSceneQueryFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	static PxU32ToName g_PxSceneQueryFilterFlag__EnumConversion[] = {
		{ "eSTATIC", static_cast<PxU32>( PxSceneQueryFilterFlag::eSTATIC ) },
		{ "eDYNAMIC", static_cast<PxU32>( PxSceneQueryFilterFlag::eDYNAMIC ) },
		{ "ePREFILTER", static_cast<PxU32>( PxSceneQueryFilterFlag::ePREFILTER ) },
		{ "ePOSTFILTER", static_cast<PxU32>( PxSceneQueryFilterFlag::ePOSTFILTER ) },
		{ "eMESH_MULTIPLE", static_cast<PxU32>( PxSceneQueryFilterFlag::eMESH_MULTIPLE ) },
		{ "eBACKFACE", static_cast<PxU32>( PxSceneQueryFilterFlag::eBACKFACE ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< PxSceneQueryFilterFlag::Enum > { PxEnumTraits() : NameConversion( g_PxSceneQueryFilterFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxScene;
	struct PxSceneGeneratedValues
	{
		PxSceneFlags Flags;
		PxVec3 Gravity;
		PxContactModifyCallback * ContactModifyCallback;
		const void * FilterShaderData;
		PxU32 FilterShaderDataSize;
		PxSimulationFilterShader FilterShader;
		PxSimulationFilterCallback * FilterCallback;
		PxU32 DynamicTreeRebuildRateHint;
		PxU32 SolverBatchSize;
		PxBounds3 VisualizationCullingBox;
		physx::pxtask::TaskManager * TaskManager;
		void * UserData;
		PxSimulationStatistics SimulationStatistics;
		void PX_PHYSX_CORE_API getValues( const PxScene* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, Flags, PxSceneGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, Gravity, PxSceneGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, ContactModifyCallback, PxSceneGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, FilterShaderData, PxSceneGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, FilterShaderDataSize, PxSceneGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, FilterShader, PxSceneGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, FilterCallback, PxSceneGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, DynamicTreeRebuildRateHint, PxSceneGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, SolverBatchSize, PxSceneGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, VisualizationCullingBox, PxSceneGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, TaskManager, PxSceneGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, UserData, PxSceneGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxScene, SimulationStatistics, PxSceneGeneratedValues)
	struct PxSceneGeneratedInfo

	{
		static const char* getClassName() { return "PxScene"; }
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_Flags, PxScene, PxSceneFlags > Flags;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_Gravity, PxScene, const PxVec3 &, PxVec3 > Gravity;
		PxIndexedPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_ClientBehaviorBits, PxScene, PxClientID, PxU32 > ClientBehaviorBits;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_ContactModifyCallback, PxScene, PxContactModifyCallback *, PxContactModifyCallback * > ContactModifyCallback;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_FilterShaderData, PxScene, const void * > FilterShaderData;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_FilterShaderDataSize, PxScene, PxU32 > FilterShaderDataSize;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_FilterShader, PxScene, PxSimulationFilterShader > FilterShader;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_FilterCallback, PxScene, PxSimulationFilterCallback * > FilterCallback;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_DynamicTreeRebuildRateHint, PxScene, PxU32, PxU32 > DynamicTreeRebuildRateHint;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_SolverBatchSize, PxScene, PxU32, PxU32 > SolverBatchSize;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_VisualizationCullingBox, PxScene, const PxBounds3 &, const PxBounds3 & > VisualizationCullingBox;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_TaskManager, PxScene, physx::pxtask::TaskManager * > TaskManager;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxScene_UserData, PxScene, void *, void * > UserData;
		SimulationStatisticsProperty SimulationStatistics;

		PX_PHYSX_CORE_API PxSceneGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxScene*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 14; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		void visitInstanceProperty( TOperator inOperator, PxU32 inPropIdx, PxU32 inStartIndex = 0 ) const
		{
			switch( inPropIdx ) {
				case 0: inOperator( Flags, inStartIndex + 0 );break; 
				case 1: inOperator( Gravity, inStartIndex + 1 );break; 
				case 2: inOperator( ClientBehaviorBits, inStartIndex + 2 );break; 
				case 3: inOperator( ContactModifyCallback, inStartIndex + 3 );break; 
				case 4: inOperator( FilterShaderData, inStartIndex + 4 );break; 
				case 5: inOperator( FilterShaderDataSize, inStartIndex + 5 );break; 
				case 6: inOperator( FilterShader, inStartIndex + 6 );break; 
				case 7: inOperator( FilterCallback, inStartIndex + 7 );break; 
				case 8: inOperator( DynamicTreeRebuildRateHint, inStartIndex + 8 );break; 
				case 9: inOperator( SolverBatchSize, inStartIndex + 9 );break; 
				case 10: inOperator( VisualizationCullingBox, inStartIndex + 10 );break; 
				case 11: inOperator( TaskManager, inStartIndex + 11 );break; 
				case 12: inOperator( UserData, inStartIndex + 12 );break; 
				case 13: inOperator( SimulationStatistics, inStartIndex + 13 );break; 
				default: PX_ASSERT( false ); break;
			}
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( Flags, inStartIndex + 0 );; 
			inOperator( Gravity, inStartIndex + 1 );; 
			inOperator( ClientBehaviorBits, inStartIndex + 2 );; 
			inOperator( ContactModifyCallback, inStartIndex + 3 );; 
			inOperator( FilterShaderData, inStartIndex + 4 );; 
			inOperator( FilterShaderDataSize, inStartIndex + 5 );; 
			inOperator( FilterShader, inStartIndex + 6 );; 
			inOperator( FilterCallback, inStartIndex + 7 );; 
			inOperator( DynamicTreeRebuildRateHint, inStartIndex + 8 );; 
			inOperator( SolverBatchSize, inStartIndex + 9 );; 
			inOperator( VisualizationCullingBox, inStartIndex + 10 );; 
			inOperator( TaskManager, inStartIndex + 11 );; 
			inOperator( UserData, inStartIndex + 12 );; 
			inOperator( SimulationStatistics, inStartIndex + 13 );; 
			return 14 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxScene> { PxSceneGeneratedInfo Info; };

	static PxU32ToName g_PxPruningStructure__EnumConversion[] = {
		{ "eNONE", static_cast<PxU32>( PxPruningStructure::eNONE ) },
		{ "eOCTREE", static_cast<PxU32>( PxPruningStructure::eOCTREE ) },
		{ "eQUADTREE", static_cast<PxU32>( PxPruningStructure::eQUADTREE ) },
		{ "eDYNAMIC_AABB_TREE", static_cast<PxU32>( PxPruningStructure::eDYNAMIC_AABB_TREE ) },
		{ "eSTATIC_AABB_TREE", static_cast<PxU32>( PxPruningStructure::eSTATIC_AABB_TREE ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< PxPruningStructure::Enum > { PxEnumTraits() : NameConversion( g_PxPruningStructure__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxSceneDesc;
	struct PxSceneDescGeneratedValues
	{
		_Bool IsValid;
		PxVec3 Gravity;
		PxSimulationEventCallback * SimulationEventCallback;
		PxContactModifyCallback * ContactModifyCallback;
		const void * FilterShaderData;
		PxU32 FilterShaderDataSize;
		PxSimulationFilterShader FilterShader;
		PxSimulationFilterCallback * FilterCallback;
		PxBounds3 MaxBounds;
		PxSceneLimits Limits;
		PxReal SweepEpsilonDistance;
		PxReal ContactCorrelationDistance;
		PxReal BounceThresholdVelocity;
		PxSceneFlags Flags;
		pxtask::CpuDispatcher * CpuDispatcher;
		pxtask::GpuDispatcher * GpuDispatcher;
		PxU32 UpAxis;
		PxU32 SubdivisionLevel;
		PxPruningStructure::Enum StaticStructure;
		PxPruningStructure::Enum DynamicStructure;
		PxU32 DynamicTreeRebuildRateHint;
		void * UserData;
		PxU32 SolverBatchSize;
		PxU32 NumSpus;
		PxReal SweptIntegrationLinearSpeedFactor;
		PxReal SweptIntegrationAngularSpeedFactor;
		void PX_PHYSX_CORE_API getValues( const PxSceneDesc* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, IsValid, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, Gravity, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, SimulationEventCallback, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, ContactModifyCallback, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, FilterShaderData, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, FilterShaderDataSize, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, FilterShader, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, FilterCallback, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, MaxBounds, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, Limits, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, SweepEpsilonDistance, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, ContactCorrelationDistance, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, BounceThresholdVelocity, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, Flags, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, CpuDispatcher, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, GpuDispatcher, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, UpAxis, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, SubdivisionLevel, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, StaticStructure, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, DynamicStructure, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, DynamicTreeRebuildRateHint, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, UserData, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, SolverBatchSize, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, NumSpus, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, SweptIntegrationLinearSpeedFactor, PxSceneDescGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneDesc, SweptIntegrationAngularSpeedFactor, PxSceneDescGeneratedValues)
	struct PxSceneDescGeneratedInfo

	{
		static const char* getClassName() { return "PxSceneDesc"; }
		PxWriteOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_ToDefault, PxSceneDesc, const PxTolerancesScale & > ToDefault;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_IsValid, PxSceneDesc, _Bool > IsValid;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_Gravity, PxSceneDesc, PxVec3, PxVec3 > Gravity;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_SimulationEventCallback, PxSceneDesc, PxSimulationEventCallback *, PxSimulationEventCallback * > SimulationEventCallback;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_ContactModifyCallback, PxSceneDesc, PxContactModifyCallback *, PxContactModifyCallback * > ContactModifyCallback;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_FilterShaderData, PxSceneDesc, const void *, const void * > FilterShaderData;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_FilterShaderDataSize, PxSceneDesc, PxU32, PxU32 > FilterShaderDataSize;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_FilterShader, PxSceneDesc, PxSimulationFilterShader, PxSimulationFilterShader > FilterShader;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_FilterCallback, PxSceneDesc, PxSimulationFilterCallback *, PxSimulationFilterCallback * > FilterCallback;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_MaxBounds, PxSceneDesc, PxBounds3, PxBounds3 > MaxBounds;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_Limits, PxSceneDesc, PxSceneLimits, PxSceneLimits > Limits;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_SweepEpsilonDistance, PxSceneDesc, PxReal, PxReal > SweepEpsilonDistance;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_ContactCorrelationDistance, PxSceneDesc, PxReal, PxReal > ContactCorrelationDistance;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_BounceThresholdVelocity, PxSceneDesc, PxReal, PxReal > BounceThresholdVelocity;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_Flags, PxSceneDesc, PxSceneFlags, PxSceneFlags > Flags;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_CpuDispatcher, PxSceneDesc, pxtask::CpuDispatcher *, pxtask::CpuDispatcher * > CpuDispatcher;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_GpuDispatcher, PxSceneDesc, pxtask::GpuDispatcher *, pxtask::GpuDispatcher * > GpuDispatcher;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_UpAxis, PxSceneDesc, PxU32, PxU32 > UpAxis;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_SubdivisionLevel, PxSceneDesc, PxU32, PxU32 > SubdivisionLevel;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_StaticStructure, PxSceneDesc, PxPruningStructure::Enum, PxPruningStructure::Enum > StaticStructure;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_DynamicStructure, PxSceneDesc, PxPruningStructure::Enum, PxPruningStructure::Enum > DynamicStructure;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_DynamicTreeRebuildRateHint, PxSceneDesc, PxU32, PxU32 > DynamicTreeRebuildRateHint;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_UserData, PxSceneDesc, void *, void * > UserData;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_SolverBatchSize, PxSceneDesc, PxU32, PxU32 > SolverBatchSize;
		//PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_NumSpus, PxSceneDesc, PxU32, PxU32 > NumSpus;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_SweptIntegrationLinearSpeedFactor, PxSceneDesc, PxReal, PxReal > SweptIntegrationLinearSpeedFactor;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneDesc_SweptIntegrationAngularSpeedFactor, PxSceneDesc, PxReal, PxReal > SweptIntegrationAngularSpeedFactor;

		PX_PHYSX_CORE_API PxSceneDescGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxSceneDesc*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 27; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		void visitInstanceProperty( TOperator inOperator, PxU32 inPropIdx, PxU32 inStartIndex = 0 ) const
		{
			switch( inPropIdx ) {
				case 0: inOperator( ToDefault, inStartIndex + 0 );break; 
				case 1: inOperator( IsValid, inStartIndex + 1 );break; 
				case 2: inOperator( Gravity, inStartIndex + 2 );break; 
				case 3: inOperator( SimulationEventCallback, inStartIndex + 3 );break; 
				case 4: inOperator( ContactModifyCallback, inStartIndex + 4 );break; 
				case 5: inOperator( FilterShaderData, inStartIndex + 5 );break; 
				case 6: inOperator( FilterShaderDataSize, inStartIndex + 6 );break; 
				case 7: inOperator( FilterShader, inStartIndex + 7 );break; 
				case 8: inOperator( FilterCallback, inStartIndex + 8 );break; 
				case 9: inOperator( MaxBounds, inStartIndex + 9 );break; 
				case 10: inOperator( Limits, inStartIndex + 10 );break; 
				case 11: inOperator( SweepEpsilonDistance, inStartIndex + 11 );break; 
				case 12: inOperator( ContactCorrelationDistance, inStartIndex + 12 );break; 
				case 13: inOperator( BounceThresholdVelocity, inStartIndex + 13 );break; 
				case 14: inOperator( Flags, inStartIndex + 14 );break; 
				case 15: inOperator( CpuDispatcher, inStartIndex + 15 );break; 
				case 16: inOperator( GpuDispatcher, inStartIndex + 16 );break; 
				case 17: inOperator( UpAxis, inStartIndex + 17 );break; 
				case 18: inOperator( SubdivisionLevel, inStartIndex + 18 );break; 
				case 19: inOperator( StaticStructure, inStartIndex + 19 );break; 
				case 20: inOperator( DynamicStructure, inStartIndex + 20 );break; 
				case 21: inOperator( DynamicTreeRebuildRateHint, inStartIndex + 21 );break; 
				case 22: inOperator( UserData, inStartIndex + 22 );break; 
				case 23: inOperator( SolverBatchSize, inStartIndex + 23 );break; 
				//case 24: inOperator( NumSpus, inStartIndex + 24 );break; 
				case 25: inOperator( SweptIntegrationLinearSpeedFactor, inStartIndex + 25 );break; 
				case 26: inOperator( SweptIntegrationAngularSpeedFactor, inStartIndex + 26 );break; 
				default: PX_ASSERT( false ); break;
			}
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( ToDefault, inStartIndex + 0 );; 
			inOperator( IsValid, inStartIndex + 1 );; 
			inOperator( Gravity, inStartIndex + 2 );; 
			inOperator( SimulationEventCallback, inStartIndex + 3 );; 
			inOperator( ContactModifyCallback, inStartIndex + 4 );; 
			inOperator( FilterShaderData, inStartIndex + 5 );; 
			inOperator( FilterShaderDataSize, inStartIndex + 6 );; 
			inOperator( FilterShader, inStartIndex + 7 );; 
			inOperator( FilterCallback, inStartIndex + 8 );; 
			inOperator( MaxBounds, inStartIndex + 9 );; 
			inOperator( Limits, inStartIndex + 10 );; 
			inOperator( SweepEpsilonDistance, inStartIndex + 11 );; 
			inOperator( ContactCorrelationDistance, inStartIndex + 12 );; 
			inOperator( BounceThresholdVelocity, inStartIndex + 13 );; 
			inOperator( Flags, inStartIndex + 14 );; 
			inOperator( CpuDispatcher, inStartIndex + 15 );; 
			inOperator( GpuDispatcher, inStartIndex + 16 );; 
			inOperator( UpAxis, inStartIndex + 17 );; 
			inOperator( SubdivisionLevel, inStartIndex + 18 );; 
			inOperator( StaticStructure, inStartIndex + 19 );; 
			inOperator( DynamicStructure, inStartIndex + 20 );; 
			inOperator( DynamicTreeRebuildRateHint, inStartIndex + 21 );; 
			inOperator( UserData, inStartIndex + 22 );; 
			inOperator( SolverBatchSize, inStartIndex + 23 );; 
			//inOperator( NumSpus, inStartIndex + 24 );; 
			inOperator( SweptIntegrationLinearSpeedFactor, inStartIndex + 25 );; 
			inOperator( SweptIntegrationAngularSpeedFactor, inStartIndex + 26 );; 
			return 27 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxSceneDesc> { PxSceneDescGeneratedInfo Info; };

	class PxTolerancesScale;
	struct PxTolerancesScaleGeneratedValues
	{
		_Bool IsValid;
		PxReal Length;
		PxReal Mass;
		PxReal Speed;
		void PX_PHYSX_CORE_API getValues( const PxTolerancesScale* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxTolerancesScale, IsValid, PxTolerancesScaleGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxTolerancesScale, Length, PxTolerancesScaleGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxTolerancesScale, Mass, PxTolerancesScaleGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxTolerancesScale, Speed, PxTolerancesScaleGeneratedValues)
	struct PxTolerancesScaleGeneratedInfo

	{
		static const char* getClassName() { return "PxTolerancesScale"; }
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxTolerancesScale_IsValid, PxTolerancesScale, _Bool > IsValid;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxTolerancesScale_Length, PxTolerancesScale, PxReal, PxReal > Length;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxTolerancesScale_Mass, PxTolerancesScale, PxReal, PxReal > Mass;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxTolerancesScale_Speed, PxTolerancesScale, PxReal, PxReal > Speed;

		PX_PHYSX_CORE_API PxTolerancesScaleGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxTolerancesScale*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 4; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		void visitInstanceProperty( TOperator inOperator, PxU32 inPropIdx, PxU32 inStartIndex = 0 ) const
		{
			switch( inPropIdx ) {
				case 0: inOperator( IsValid, inStartIndex + 0 );break; 
				case 1: inOperator( Length, inStartIndex + 1 );break; 
				case 2: inOperator( Mass, inStartIndex + 2 );break; 
				case 3: inOperator( Speed, inStartIndex + 3 );break; 
				default: PX_ASSERT( false ); break;
			}
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( IsValid, inStartIndex + 0 );; 
			inOperator( Length, inStartIndex + 1 );; 
			inOperator( Mass, inStartIndex + 2 );; 
			inOperator( Speed, inStartIndex + 3 );; 
			return 4 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxTolerancesScale> { PxTolerancesScaleGeneratedInfo Info; };

	class PxGeometry;
	struct PxGeometryGeneratedValues
	{
		PxGeometryType::Enum Type;
		void PX_PHYSX_CORE_API getValues( const PxGeometry* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxGeometry, Type, PxGeometryGeneratedValues)
	struct PxGeometryGeneratedInfo

	{
		static const char* getClassName() { return "PxGeometry"; }
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxGeometry_Type, PxGeometry, PxGeometryType::Enum > Type;

		PX_PHYSX_CORE_API PxGeometryGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxGeometry*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 1; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		void visitInstanceProperty( TOperator inOperator, PxU32 inPropIdx, PxU32 inStartIndex = 0 ) const
		{
			switch( inPropIdx ) {
				case 0: inOperator( Type, inStartIndex + 0 );break; 
				default: PX_ASSERT( false ); break;
			}
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( Type, inStartIndex + 0 );; 
			return 1 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxGeometry> { PxGeometryGeneratedInfo Info; };

	class PxPhysics;
	struct PxPhysicsGeneratedValues
	{
		PxTolerancesScale TolerancesScale;
		void PX_PHYSX_CORE_API getValues( const PxPhysics* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxPhysics, TolerancesScale, PxPhysicsGeneratedValues)
	struct PxPhysicsGeneratedInfo

	{
		static const char* getClassName() { return "PxPhysics"; }
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxPhysics_TolerancesScale, PxPhysics, const PxTolerancesScale & > TolerancesScale;

		PX_PHYSX_CORE_API PxPhysicsGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxPhysics*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 1; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		void visitInstanceProperty( TOperator inOperator, PxU32 inPropIdx, PxU32 inStartIndex = 0 ) const
		{
			switch( inPropIdx ) {
				case 0: inOperator( TolerancesScale, inStartIndex + 0 );break; 
				default: PX_ASSERT( false ); break;
			}
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( TolerancesScale, inStartIndex + 0 );; 
			return 1 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxPhysics> { PxPhysicsGeneratedInfo Info; };

	class PxSceneLimits;
	struct PxSceneLimitsGeneratedValues
	{
		_Bool IsValid;
		PxU32 MaxNbActors;
		PxU32 MaxNbBodies;
		PxU32 MaxNbStaticShapes;
		PxU32 MaxNbDynamicShapes;
		PxU32 MaxNbConstraints;
		void PX_PHYSX_CORE_API getValues( const PxSceneLimits* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneLimits, IsValid, PxSceneLimitsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneLimits, MaxNbActors, PxSceneLimitsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneLimits, MaxNbBodies, PxSceneLimitsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneLimits, MaxNbStaticShapes, PxSceneLimitsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneLimits, MaxNbDynamicShapes, PxSceneLimitsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSceneLimits, MaxNbConstraints, PxSceneLimitsGeneratedValues)
	struct PxSceneLimitsGeneratedInfo

	{
		static const char* getClassName() { return "PxSceneLimits"; }
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneLimits_IsValid, PxSceneLimits, _Bool > IsValid;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneLimits_MaxNbActors, PxSceneLimits, PxU32, PxU32 > MaxNbActors;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneLimits_MaxNbBodies, PxSceneLimits, PxU32, PxU32 > MaxNbBodies;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneLimits_MaxNbStaticShapes, PxSceneLimits, PxU32, PxU32 > MaxNbStaticShapes;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneLimits_MaxNbDynamicShapes, PxSceneLimits, PxU32, PxU32 > MaxNbDynamicShapes;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSceneLimits_MaxNbConstraints, PxSceneLimits, PxU32, PxU32 > MaxNbConstraints;

		PX_PHYSX_CORE_API PxSceneLimitsGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxSceneLimits*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 6; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		void visitInstanceProperty( TOperator inOperator, PxU32 inPropIdx, PxU32 inStartIndex = 0 ) const
		{
			switch( inPropIdx ) {
				case 0: inOperator( IsValid, inStartIndex + 0 );break; 
				case 1: inOperator( MaxNbActors, inStartIndex + 1 );break; 
				case 2: inOperator( MaxNbBodies, inStartIndex + 2 );break; 
				case 3: inOperator( MaxNbStaticShapes, inStartIndex + 3 );break; 
				case 4: inOperator( MaxNbDynamicShapes, inStartIndex + 4 );break; 
				case 5: inOperator( MaxNbConstraints, inStartIndex + 5 );break; 
				default: PX_ASSERT( false ); break;
			}
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( IsValid, inStartIndex + 0 );; 
			inOperator( MaxNbActors, inStartIndex + 1 );; 
			inOperator( MaxNbBodies, inStartIndex + 2 );; 
			inOperator( MaxNbStaticShapes, inStartIndex + 3 );; 
			inOperator( MaxNbDynamicShapes, inStartIndex + 4 );; 
			inOperator( MaxNbConstraints, inStartIndex + 5 );; 
			return 6 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxSceneLimits> { PxSceneLimitsGeneratedInfo Info; };

	static PxU32ToName g_PxSimulationStatistics__VolumeTypeConversion[] = {
		{ "eRIGID_BODY", static_cast<PxU32>( PxSimulationStatistics::eRIGID_BODY ) },
		{ "ePARTICLE_SYSTEM", static_cast<PxU32>( PxSimulationStatistics::ePARTICLE_SYSTEM ) },
		{ "eDEFORMABLE", static_cast<PxU32>( PxSimulationStatistics::eDEFORMABLE ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< PxSimulationStatistics::VolumeType > { PxEnumTraits() : NameConversion( g_PxSimulationStatistics__VolumeTypeConversion ) {} const PxU32ToName* NameConversion; }; 
	static PxU32ToName g_PxSimulationStatistics__RbPairStatsTypeConversion[] = {
		{ "eDISCRETE_CONTACT_PAIRS", static_cast<PxU32>( PxSimulationStatistics::eDISCRETE_CONTACT_PAIRS ) },
		{ "eSWEPT_CONTACT_PAIRS", static_cast<PxU32>( PxSimulationStatistics::eSWEPT_CONTACT_PAIRS ) },
		{ "eSWEPT_INTEGRATION_PAIRS", static_cast<PxU32>( PxSimulationStatistics::eSWEPT_INTEGRATION_PAIRS ) },
		{ "eMODIFIED_CONTACT_PAIRS", static_cast<PxU32>( PxSimulationStatistics::eMODIFIED_CONTACT_PAIRS ) },
		{ "eTRIGGER_PAIRS", static_cast<PxU32>( PxSimulationStatistics::eTRIGGER_PAIRS ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< PxSimulationStatistics::RbPairStatsType > { PxEnumTraits() : NameConversion( g_PxSimulationStatistics__RbPairStatsTypeConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxSimulationStatistics;
	struct PxSimulationStatisticsGeneratedValues
	{
		PxU32 NumActiveConstraints;
		PxU32 NumActiveDynamicBodies;
		PxU32 NumActiveKinematicBodies;
		PxU32 NumStaticBodies;
		PxU32 NumDynamicBodies;
		PxU32 NumAxisSolverConstraints;
		PxU32 NumDiscreteContactPairs[PxGeometryType::eGEOMETRY_COUNT][PxGeometryType::eGEOMETRY_COUNT];
		PxU32 NumModifiedContactPairs[PxGeometryType::eGEOMETRY_COUNT][PxGeometryType::eGEOMETRY_COUNT];
		PxU32 NumSweptContactPairs[PxGeometryType::eGEOMETRY_COUNT][PxGeometryType::eGEOMETRY_COUNT];
		PxU32 NumSweptIntegrationPairs[PxGeometryType::eGEOMETRY_COUNT][PxGeometryType::eGEOMETRY_COUNT];
		PxU32 NumTriggerPairs[PxGeometryType::eGEOMETRY_COUNT][PxGeometryType::eGEOMETRY_COUNT];
		PxU32 NumBroadPhaseAdds[PxSimulationStatistics::eVOLUME_COUNT];
		PxU32 NumBroadPhaseRemoves[PxSimulationStatistics::eVOLUME_COUNT];
		PxU32 NumShapes[PxGeometryType::eGEOMETRY_COUNT];
		void PX_PHYSX_CORE_API getValues( const PxSimulationStatistics* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSimulationStatistics, NumActiveConstraints, PxSimulationStatisticsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSimulationStatistics, NumActiveDynamicBodies, PxSimulationStatisticsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSimulationStatistics, NumActiveKinematicBodies, PxSimulationStatisticsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSimulationStatistics, NumStaticBodies, PxSimulationStatisticsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSimulationStatistics, NumDynamicBodies, PxSimulationStatisticsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSimulationStatistics, NumAxisSolverConstraints, PxSimulationStatisticsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSimulationStatistics, NumDiscreteContactPairs, PxSimulationStatisticsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSimulationStatistics, NumModifiedContactPairs, PxSimulationStatisticsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSimulationStatistics, NumSweptContactPairs, PxSimulationStatisticsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSimulationStatistics, NumSweptIntegrationPairs, PxSimulationStatisticsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSimulationStatistics, NumTriggerPairs, PxSimulationStatisticsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSimulationStatistics, NumBroadPhaseAdds, PxSimulationStatisticsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSimulationStatistics, NumBroadPhaseRemoves, PxSimulationStatisticsGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSimulationStatistics, NumShapes, PxSimulationStatisticsGeneratedValues)
	struct PxSimulationStatisticsGeneratedInfo

	{
		static const char* getClassName() { return "PxSimulationStatistics"; }
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSimulationStatistics_NumActiveConstraints, PxSimulationStatistics, PxU32, PxU32 > NumActiveConstraints;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSimulationStatistics_NumActiveDynamicBodies, PxSimulationStatistics, PxU32, PxU32 > NumActiveDynamicBodies;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSimulationStatistics_NumActiveKinematicBodies, PxSimulationStatistics, PxU32, PxU32 > NumActiveKinematicBodies;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSimulationStatistics_NumStaticBodies, PxSimulationStatistics, PxU32, PxU32 > NumStaticBodies;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSimulationStatistics_NumDynamicBodies, PxSimulationStatistics, PxU32, PxU32 > NumDynamicBodies;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSimulationStatistics_NumAxisSolverConstraints, PxSimulationStatistics, PxU32, PxU32 > NumAxisSolverConstraints;
		NumDiscreteContactPairsProperty NumDiscreteContactPairs;
		NumModifiedContactPairsProperty NumModifiedContactPairs;
		NumSweptContactPairsProperty NumSweptContactPairs;
		NumSweptIntegrationPairsProperty NumSweptIntegrationPairs;
		NumTriggerPairsProperty NumTriggerPairs;
		NumBroadPhaseAddsProperty NumBroadPhaseAdds;
		NumBroadPhaseRemovesProperty NumBroadPhaseRemoves;
		NumShapesProperty NumShapes;

		PX_PHYSX_CORE_API PxSimulationStatisticsGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxSimulationStatistics*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 14; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		void visitInstanceProperty( TOperator inOperator, PxU32 inPropIdx, PxU32 inStartIndex = 0 ) const
		{
			switch( inPropIdx ) {
				case 0: inOperator( NumActiveConstraints, inStartIndex + 0 );break; 
				case 1: inOperator( NumActiveDynamicBodies, inStartIndex + 1 );break; 
				case 2: inOperator( NumActiveKinematicBodies, inStartIndex + 2 );break; 
				case 3: inOperator( NumStaticBodies, inStartIndex + 3 );break; 
				case 4: inOperator( NumDynamicBodies, inStartIndex + 4 );break; 
				case 5: inOperator( NumAxisSolverConstraints, inStartIndex + 5 );break; 
				case 6: inOperator( NumDiscreteContactPairs, inStartIndex + 6 );break; 
				case 7: inOperator( NumModifiedContactPairs, inStartIndex + 7 );break; 
				case 8: inOperator( NumSweptContactPairs, inStartIndex + 8 );break; 
				case 9: inOperator( NumSweptIntegrationPairs, inStartIndex + 9 );break; 
				case 10: inOperator( NumTriggerPairs, inStartIndex + 10 );break; 
				case 11: inOperator( NumBroadPhaseAdds, inStartIndex + 11 );break; 
				case 12: inOperator( NumBroadPhaseRemoves, inStartIndex + 12 );break; 
				case 13: inOperator( NumShapes, inStartIndex + 13 );break; 
				default: PX_ASSERT( false ); break;
			}
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( NumActiveConstraints, inStartIndex + 0 );; 
			inOperator( NumActiveDynamicBodies, inStartIndex + 1 );; 
			inOperator( NumActiveKinematicBodies, inStartIndex + 2 );; 
			inOperator( NumStaticBodies, inStartIndex + 3 );; 
			inOperator( NumDynamicBodies, inStartIndex + 4 );; 
			inOperator( NumAxisSolverConstraints, inStartIndex + 5 );; 
			inOperator( NumDiscreteContactPairs, inStartIndex + 6 );; 
			inOperator( NumModifiedContactPairs, inStartIndex + 7 );; 
			inOperator( NumSweptContactPairs, inStartIndex + 8 );; 
			inOperator( NumSweptIntegrationPairs, inStartIndex + 9 );; 
			inOperator( NumTriggerPairs, inStartIndex + 10 );; 
			inOperator( NumBroadPhaseAdds, inStartIndex + 11 );; 
			inOperator( NumBroadPhaseRemoves, inStartIndex + 12 );; 
			inOperator( NumShapes, inStartIndex + 13 );; 
			return 14 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxSimulationStatistics> { PxSimulationStatisticsGeneratedInfo Info; };

	static PxU32ToName g_PxDataAccessFlag__EnumConversion[] = {
		{ "eREADABLE", static_cast<PxU32>( PxDataAccessFlag::eREADABLE ) },
		{ "eWRITABLE", static_cast<PxU32>( PxDataAccessFlag::eWRITABLE ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< PxDataAccessFlag::Enum > { PxEnumTraits() : NameConversion( g_PxDataAccessFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxLockedData;
	struct PxLockedDataGeneratedValues
	{
		void PX_PHYSX_CORE_API getValues( const PxLockedData* inSource );
	};
	struct PxLockedDataGeneratedInfo

	{
		static const char* getClassName() { return "PxLockedData"; }

		PX_PHYSX_CORE_API PxLockedDataGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxLockedData*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 0; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		void visitInstanceProperty( TOperator inOperator, PxU32 inPropIdx, PxU32 inStartIndex = 0 ) const
		{
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			return 0 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxLockedData> { PxLockedDataGeneratedInfo Info; };

	class PxParticleReadData;
	struct PxParticleReadDataGeneratedValues
		: PxLockedDataGeneratedValues	{
		PxU32 NumValidParticles;
		PxU32 ValidParticleRange;
		const PxU32 * ValidParticleBitmap;
		PxStrideIterator<const PxVec3> PositionBuffer;
		PxStrideIterator<const PxVec3> VelocityBuffer;
		PxStrideIterator<const PxF32> RestOffsetBuffer;
		PxStrideIterator<const PxParticleFlags> FlagsBuffer;
		PxStrideIterator<const PxVec3> CollisionNormalBuffer;
		void PX_PHYSX_CORE_API getValues( const PxParticleReadData* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleReadData, NumValidParticles, PxParticleReadDataGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleReadData, ValidParticleRange, PxParticleReadDataGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleReadData, ValidParticleBitmap, PxParticleReadDataGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleReadData, PositionBuffer, PxParticleReadDataGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleReadData, VelocityBuffer, PxParticleReadDataGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleReadData, RestOffsetBuffer, PxParticleReadDataGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleReadData, FlagsBuffer, PxParticleReadDataGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxParticleReadData, CollisionNormalBuffer, PxParticleReadDataGeneratedValues)
	struct PxParticleReadDataGeneratedInfo
		: PxLockedDataGeneratedInfo
	{
		static const char* getClassName() { return "PxParticleReadData"; }
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleReadData_NumValidParticles, PxParticleReadData, PxU32, PxU32 > NumValidParticles;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleReadData_ValidParticleRange, PxParticleReadData, PxU32, PxU32 > ValidParticleRange;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleReadData_ValidParticleBitmap, PxParticleReadData, const PxU32 *, const PxU32 * > ValidParticleBitmap;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleReadData_PositionBuffer, PxParticleReadData, PxStrideIterator<const PxVec3>, PxStrideIterator<const PxVec3> > PositionBuffer;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleReadData_VelocityBuffer, PxParticleReadData, PxStrideIterator<const PxVec3>, PxStrideIterator<const PxVec3> > VelocityBuffer;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleReadData_RestOffsetBuffer, PxParticleReadData, PxStrideIterator<const PxF32>, PxStrideIterator<const PxF32> > RestOffsetBuffer;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleReadData_FlagsBuffer, PxParticleReadData, PxStrideIterator<const PxParticleFlags>, PxStrideIterator<const PxParticleFlags> > FlagsBuffer;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxParticleReadData_CollisionNormalBuffer, PxParticleReadData, PxStrideIterator<const PxVec3>, PxStrideIterator<const PxVec3> > CollisionNormalBuffer;

		PX_PHYSX_CORE_API PxParticleReadDataGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxParticleReadData*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			inOperator( *static_cast<PxLockedDataGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxLockedDataGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxLockedDataGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 8; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxLockedDataGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		void visitInstanceProperty( TOperator inOperator, PxU32 inPropIdx, PxU32 inStartIndex = 0 ) const
		{
			switch( inPropIdx ) {
				case 0: inOperator( NumValidParticles, inStartIndex + 0 );break; 
				case 1: inOperator( ValidParticleRange, inStartIndex + 1 );break; 
				case 2: inOperator( ValidParticleBitmap, inStartIndex + 2 );break; 
				case 3: inOperator( PositionBuffer, inStartIndex + 3 );break; 
				case 4: inOperator( VelocityBuffer, inStartIndex + 4 );break; 
				case 5: inOperator( RestOffsetBuffer, inStartIndex + 5 );break; 
				case 6: inOperator( FlagsBuffer, inStartIndex + 6 );break; 
				case 7: inOperator( CollisionNormalBuffer, inStartIndex + 7 );break; 
				default: PX_ASSERT( false ); break;
			}
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( NumValidParticles, inStartIndex + 0 );; 
			inOperator( ValidParticleRange, inStartIndex + 1 );; 
			inOperator( ValidParticleBitmap, inStartIndex + 2 );; 
			inOperator( PositionBuffer, inStartIndex + 3 );; 
			inOperator( VelocityBuffer, inStartIndex + 4 );; 
			inOperator( RestOffsetBuffer, inStartIndex + 5 );; 
			inOperator( FlagsBuffer, inStartIndex + 6 );; 
			inOperator( CollisionNormalBuffer, inStartIndex + 7 );; 
			return 8 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxParticleReadData> { PxParticleReadDataGeneratedInfo Info; };

	class PxArticulationLink;
	struct PxArticulationLinkGeneratedValues
		: PxRigidBodyGeneratedValues	{
		PxArticulationJoint * InboundJoint;
		void PX_PHYSX_CORE_API getValues( const PxArticulationLink* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulationLink, InboundJoint, PxArticulationLinkGeneratedValues)
	struct PxArticulationLinkGeneratedInfo
		: PxRigidBodyGeneratedInfo
	{
		static const char* getClassName() { return "PxArticulationLink"; }
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulationLink_InboundJoint, PxArticulationLink, PxArticulationJoint * > InboundJoint;
		PxReadOnlyCollectionPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulationLink_Children, PxArticulationLink, PxArticulationLink > Children;

		PX_PHYSX_CORE_API PxArticulationLinkGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxArticulationLink*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			inOperator( *static_cast<PxRigidBodyGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxRigidBodyGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxRigidBodyGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 2; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxRigidBodyGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		void visitInstanceProperty( TOperator inOperator, PxU32 inPropIdx, PxU32 inStartIndex = 0 ) const
		{
			switch( inPropIdx ) {
				case 0: inOperator( InboundJoint, inStartIndex + 0 );break; 
				case 1: inOperator( Children, inStartIndex + 1 );break; 
				default: PX_ASSERT( false ); break;
			}
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( InboundJoint, inStartIndex + 0 );; 
			inOperator( Children, inStartIndex + 1 );; 
			return 2 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxArticulationLink> { PxArticulationLinkGeneratedInfo Info; };

	class PxSphereGeometry;
	struct PxSphereGeometryGeneratedValues
		: PxGeometryGeneratedValues	{
		_Bool IsValid;
		PxReal Radius;
		void PX_PHYSX_CORE_API getValues( const PxSphereGeometry* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSphereGeometry, IsValid, PxSphereGeometryGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxSphereGeometry, Radius, PxSphereGeometryGeneratedValues)
	struct PxSphereGeometryGeneratedInfo
		: PxGeometryGeneratedInfo
	{
		static const char* getClassName() { return "PxSphereGeometry"; }
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxSphereGeometry_IsValid, PxSphereGeometry, _Bool > IsValid;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxSphereGeometry_Radius, PxSphereGeometry, PxReal, PxReal > Radius;

		PX_PHYSX_CORE_API PxSphereGeometryGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxSphereGeometry*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			inOperator( *static_cast<PxGeometryGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxGeometryGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxGeometryGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 2; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxGeometryGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		void visitInstanceProperty( TOperator inOperator, PxU32 inPropIdx, PxU32 inStartIndex = 0 ) const
		{
			switch( inPropIdx ) {
				case 0: inOperator( IsValid, inStartIndex + 0 );break; 
				case 1: inOperator( Radius, inStartIndex + 1 );break; 
				default: PX_ASSERT( false ); break;
			}
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( IsValid, inStartIndex + 0 );; 
			inOperator( Radius, inStartIndex + 1 );; 
			return 2 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxSphereGeometry> { PxSphereGeometryGeneratedInfo Info; };

	class PxBoxGeometry;
	struct PxBoxGeometryGeneratedValues
		: PxGeometryGeneratedValues	{
		_Bool IsValid;
		PxVec3 HalfExtents;
		void PX_PHYSX_CORE_API getValues( const PxBoxGeometry* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxBoxGeometry, IsValid, PxBoxGeometryGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxBoxGeometry, HalfExtents, PxBoxGeometryGeneratedValues)
	struct PxBoxGeometryGeneratedInfo
		: PxGeometryGeneratedInfo
	{
		static const char* getClassName() { return "PxBoxGeometry"; }
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxBoxGeometry_IsValid, PxBoxGeometry, _Bool > IsValid;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxBoxGeometry_HalfExtents, PxBoxGeometry, PxVec3, PxVec3 > HalfExtents;

		PX_PHYSX_CORE_API PxBoxGeometryGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxBoxGeometry*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			inOperator( *static_cast<PxGeometryGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxGeometryGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxGeometryGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 2; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxGeometryGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		void visitInstanceProperty( TOperator inOperator, PxU32 inPropIdx, PxU32 inStartIndex = 0 ) const
		{
			switch( inPropIdx ) {
				case 0: inOperator( IsValid, inStartIndex + 0 );break; 
				case 1: inOperator( HalfExtents, inStartIndex + 1 );break; 
				default: PX_ASSERT( false ); break;
			}
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( IsValid, inStartIndex + 0 );; 
			inOperator( HalfExtents, inStartIndex + 1 );; 
			return 2 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxBoxGeometry> { PxBoxGeometryGeneratedInfo Info; };

	class PxCapsuleGeometry;
	struct PxCapsuleGeometryGeneratedValues
		: PxGeometryGeneratedValues	{
		_Bool IsValid;
		PxReal Radius;
		PxReal HalfHeight;
		void PX_PHYSX_CORE_API getValues( const PxCapsuleGeometry* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxCapsuleGeometry, IsValid, PxCapsuleGeometryGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxCapsuleGeometry, Radius, PxCapsuleGeometryGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxCapsuleGeometry, HalfHeight, PxCapsuleGeometryGeneratedValues)
	struct PxCapsuleGeometryGeneratedInfo
		: PxGeometryGeneratedInfo
	{
		static const char* getClassName() { return "PxCapsuleGeometry"; }
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxCapsuleGeometry_IsValid, PxCapsuleGeometry, _Bool > IsValid;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxCapsuleGeometry_Radius, PxCapsuleGeometry, PxReal, PxReal > Radius;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxCapsuleGeometry_HalfHeight, PxCapsuleGeometry, PxReal, PxReal > HalfHeight;

		PX_PHYSX_CORE_API PxCapsuleGeometryGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxCapsuleGeometry*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			inOperator( *static_cast<PxGeometryGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxGeometryGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxGeometryGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 3; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxGeometryGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		void visitInstanceProperty( TOperator inOperator, PxU32 inPropIdx, PxU32 inStartIndex = 0 ) const
		{
			switch( inPropIdx ) {
				case 0: inOperator( IsValid, inStartIndex + 0 );break; 
				case 1: inOperator( Radius, inStartIndex + 1 );break; 
				case 2: inOperator( HalfHeight, inStartIndex + 2 );break; 
				default: PX_ASSERT( false ); break;
			}
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( IsValid, inStartIndex + 0 );; 
			inOperator( Radius, inStartIndex + 1 );; 
			inOperator( HalfHeight, inStartIndex + 2 );; 
			return 3 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxCapsuleGeometry> { PxCapsuleGeometryGeneratedInfo Info; };

	class PxPlaneGeometry;
	struct PxPlaneGeometryGeneratedValues
		: PxGeometryGeneratedValues	{
		_Bool IsValid;
		void PX_PHYSX_CORE_API getValues( const PxPlaneGeometry* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxPlaneGeometry, IsValid, PxPlaneGeometryGeneratedValues)
	struct PxPlaneGeometryGeneratedInfo
		: PxGeometryGeneratedInfo
	{
		static const char* getClassName() { return "PxPlaneGeometry"; }
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxPlaneGeometry_IsValid, PxPlaneGeometry, _Bool > IsValid;

		PX_PHYSX_CORE_API PxPlaneGeometryGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxPlaneGeometry*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			inOperator( *static_cast<PxGeometryGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxGeometryGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxGeometryGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 1; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxGeometryGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		void visitInstanceProperty( TOperator inOperator, PxU32 inPropIdx, PxU32 inStartIndex = 0 ) const
		{
			switch( inPropIdx ) {
				case 0: inOperator( IsValid, inStartIndex + 0 );break; 
				default: PX_ASSERT( false ); break;
			}
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( IsValid, inStartIndex + 0 );; 
			return 1 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxPlaneGeometry> { PxPlaneGeometryGeneratedInfo Info; };

	class PxConvexMeshGeometry;
	struct PxConvexMeshGeometryGeneratedValues
		: PxGeometryGeneratedValues	{
		_Bool IsValid;
		PxMeshScale Scale;
		PxConvexMesh * ConvexMesh;
		void PX_PHYSX_CORE_API getValues( const PxConvexMeshGeometry* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxConvexMeshGeometry, IsValid, PxConvexMeshGeometryGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxConvexMeshGeometry, Scale, PxConvexMeshGeometryGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxConvexMeshGeometry, ConvexMesh, PxConvexMeshGeometryGeneratedValues)
	struct PxConvexMeshGeometryGeneratedInfo
		: PxGeometryGeneratedInfo
	{
		static const char* getClassName() { return "PxConvexMeshGeometry"; }
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxConvexMeshGeometry_IsValid, PxConvexMeshGeometry, _Bool > IsValid;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxConvexMeshGeometry_Scale, PxConvexMeshGeometry, PxMeshScale, PxMeshScale > Scale;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxConvexMeshGeometry_ConvexMesh, PxConvexMeshGeometry, PxConvexMesh *, PxConvexMesh * > ConvexMesh;

		PX_PHYSX_CORE_API PxConvexMeshGeometryGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxConvexMeshGeometry*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			inOperator( *static_cast<PxGeometryGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxGeometryGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxGeometryGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 3; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxGeometryGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		void visitInstanceProperty( TOperator inOperator, PxU32 inPropIdx, PxU32 inStartIndex = 0 ) const
		{
			switch( inPropIdx ) {
				case 0: inOperator( IsValid, inStartIndex + 0 );break; 
				case 1: inOperator( Scale, inStartIndex + 1 );break; 
				case 2: inOperator( ConvexMesh, inStartIndex + 2 );break; 
				default: PX_ASSERT( false ); break;
			}
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( IsValid, inStartIndex + 0 );; 
			inOperator( Scale, inStartIndex + 1 );; 
			inOperator( ConvexMesh, inStartIndex + 2 );; 
			return 3 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxConvexMeshGeometry> { PxConvexMeshGeometryGeneratedInfo Info; };

	static PxU32ToName g_PxMeshGeometryFlag__EnumConversion[] = {
		{ "eSMOOTH_SPHERE_COLLISIONS", static_cast<PxU32>( PxMeshGeometryFlag::eSMOOTH_SPHERE_COLLISIONS ) },
		{ "eDOUBLE_SIDED", static_cast<PxU32>( PxMeshGeometryFlag::eDOUBLE_SIDED ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< PxMeshGeometryFlag::Enum > { PxEnumTraits() : NameConversion( g_PxMeshGeometryFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxTriangleMeshGeometry;
	struct PxTriangleMeshGeometryGeneratedValues
		: PxGeometryGeneratedValues	{
		_Bool IsValid;
		PxMeshScale Scale;
		PxMeshGeometryFlags MeshFlags;
		PxTriangleMesh * TriangleMesh;
		void PX_PHYSX_CORE_API getValues( const PxTriangleMeshGeometry* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxTriangleMeshGeometry, IsValid, PxTriangleMeshGeometryGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxTriangleMeshGeometry, Scale, PxTriangleMeshGeometryGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxTriangleMeshGeometry, MeshFlags, PxTriangleMeshGeometryGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxTriangleMeshGeometry, TriangleMesh, PxTriangleMeshGeometryGeneratedValues)
	struct PxTriangleMeshGeometryGeneratedInfo
		: PxGeometryGeneratedInfo
	{
		static const char* getClassName() { return "PxTriangleMeshGeometry"; }
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxTriangleMeshGeometry_IsValid, PxTriangleMeshGeometry, _Bool > IsValid;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxTriangleMeshGeometry_Scale, PxTriangleMeshGeometry, PxMeshScale, PxMeshScale > Scale;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxTriangleMeshGeometry_MeshFlags, PxTriangleMeshGeometry, PxMeshGeometryFlags, PxMeshGeometryFlags > MeshFlags;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxTriangleMeshGeometry_TriangleMesh, PxTriangleMeshGeometry, PxTriangleMesh *, PxTriangleMesh * > TriangleMesh;

		PX_PHYSX_CORE_API PxTriangleMeshGeometryGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxTriangleMeshGeometry*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			inOperator( *static_cast<PxGeometryGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxGeometryGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxGeometryGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 4; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxGeometryGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		void visitInstanceProperty( TOperator inOperator, PxU32 inPropIdx, PxU32 inStartIndex = 0 ) const
		{
			switch( inPropIdx ) {
				case 0: inOperator( IsValid, inStartIndex + 0 );break; 
				case 1: inOperator( Scale, inStartIndex + 1 );break; 
				case 2: inOperator( MeshFlags, inStartIndex + 2 );break; 
				case 3: inOperator( TriangleMesh, inStartIndex + 3 );break; 
				default: PX_ASSERT( false ); break;
			}
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( IsValid, inStartIndex + 0 );; 
			inOperator( Scale, inStartIndex + 1 );; 
			inOperator( MeshFlags, inStartIndex + 2 );; 
			inOperator( TriangleMesh, inStartIndex + 3 );; 
			return 4 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxTriangleMeshGeometry> { PxTriangleMeshGeometryGeneratedInfo Info; };

	class PxHeightFieldGeometry;
	struct PxHeightFieldGeometryGeneratedValues
		: PxGeometryGeneratedValues	{
		_Bool IsValid;
		PxHeightField * HeightField;
		PxReal HeightScale;
		PxReal RowScale;
		PxReal ColumnScale;
		PxMeshGeometryFlags HeightFieldFlags;
		void PX_PHYSX_CORE_API getValues( const PxHeightFieldGeometry* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxHeightFieldGeometry, IsValid, PxHeightFieldGeometryGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxHeightFieldGeometry, HeightField, PxHeightFieldGeometryGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxHeightFieldGeometry, HeightScale, PxHeightFieldGeometryGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxHeightFieldGeometry, RowScale, PxHeightFieldGeometryGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxHeightFieldGeometry, ColumnScale, PxHeightFieldGeometryGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxHeightFieldGeometry, HeightFieldFlags, PxHeightFieldGeometryGeneratedValues)
	struct PxHeightFieldGeometryGeneratedInfo
		: PxGeometryGeneratedInfo
	{
		static const char* getClassName() { return "PxHeightFieldGeometry"; }
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxHeightFieldGeometry_IsValid, PxHeightFieldGeometry, _Bool > IsValid;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxHeightFieldGeometry_HeightField, PxHeightFieldGeometry, PxHeightField *, PxHeightField * > HeightField;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxHeightFieldGeometry_HeightScale, PxHeightFieldGeometry, PxReal, PxReal > HeightScale;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxHeightFieldGeometry_RowScale, PxHeightFieldGeometry, PxReal, PxReal > RowScale;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxHeightFieldGeometry_ColumnScale, PxHeightFieldGeometry, PxReal, PxReal > ColumnScale;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxHeightFieldGeometry_HeightFieldFlags, PxHeightFieldGeometry, PxMeshGeometryFlags, PxMeshGeometryFlags > HeightFieldFlags;

		PX_PHYSX_CORE_API PxHeightFieldGeometryGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxHeightFieldGeometry*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
			inOperator( *static_cast<PxGeometryGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxGeometryGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxGeometryGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 6; }
		static PxU32 totalPropertyCount() { return instancePropertyCount()
				+ PxGeometryGeneratedInfo::totalPropertyCount(); }
		template<typename TOperator>
		void visitInstanceProperty( TOperator inOperator, PxU32 inPropIdx, PxU32 inStartIndex = 0 ) const
		{
			switch( inPropIdx ) {
				case 0: inOperator( IsValid, inStartIndex + 0 );break; 
				case 1: inOperator( HeightField, inStartIndex + 1 );break; 
				case 2: inOperator( HeightScale, inStartIndex + 2 );break; 
				case 3: inOperator( RowScale, inStartIndex + 3 );break; 
				case 4: inOperator( ColumnScale, inStartIndex + 4 );break; 
				case 5: inOperator( HeightFieldFlags, inStartIndex + 5 );break; 
				default: PX_ASSERT( false ); break;
			}
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( IsValid, inStartIndex + 0 );; 
			inOperator( HeightField, inStartIndex + 1 );; 
			inOperator( HeightScale, inStartIndex + 2 );; 
			inOperator( RowScale, inStartIndex + 3 );; 
			inOperator( ColumnScale, inStartIndex + 4 );; 
			inOperator( HeightFieldFlags, inStartIndex + 5 );; 
			return 6 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxHeightFieldGeometry> { PxHeightFieldGeometryGeneratedInfo Info; };

	class PxArticulationJoint;
	struct PxArticulationJointGeneratedValues
	{
		PxTransform ParentPose;
		PxTransform ChildPose;
		PxQuat TargetOrientation;
		PxVec3 TargetVelocity;
		PxReal Spring;
		PxReal Damping;
		PxReal InternalCompliance;
		PxReal ExternalCompliance;
		PxReal SwingLimit[2];
		_Bool SwingLimitEnabled;
		PxReal TwistLimit[2];
		_Bool TwistLimitEnabled;
		void PX_PHYSX_CORE_API getValues( const PxArticulationJoint* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulationJoint, ParentPose, PxArticulationJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulationJoint, ChildPose, PxArticulationJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulationJoint, TargetOrientation, PxArticulationJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulationJoint, TargetVelocity, PxArticulationJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulationJoint, Spring, PxArticulationJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulationJoint, Damping, PxArticulationJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulationJoint, InternalCompliance, PxArticulationJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulationJoint, ExternalCompliance, PxArticulationJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulationJoint, SwingLimit, PxArticulationJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulationJoint, SwingLimitEnabled, PxArticulationJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulationJoint, TwistLimit, PxArticulationJointGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxArticulationJoint, TwistLimitEnabled, PxArticulationJointGeneratedValues)
	struct PxArticulationJointGeneratedInfo

	{
		static const char* getClassName() { return "PxArticulationJoint"; }
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulationJoint_ParentPose, PxArticulationJoint, const PxTransform &, PxTransform > ParentPose;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulationJoint_ChildPose, PxArticulationJoint, const PxTransform &, PxTransform > ChildPose;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulationJoint_TargetOrientation, PxArticulationJoint, const PxQuat &, PxQuat > TargetOrientation;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulationJoint_TargetVelocity, PxArticulationJoint, const PxVec3 &, PxVec3 > TargetVelocity;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulationJoint_Spring, PxArticulationJoint, PxReal, PxReal > Spring;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulationJoint_Damping, PxArticulationJoint, PxReal, PxReal > Damping;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulationJoint_InternalCompliance, PxArticulationJoint, PxReal, PxReal > InternalCompliance;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulationJoint_ExternalCompliance, PxArticulationJoint, PxReal, PxReal > ExternalCompliance;
		PxRangePropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulationJoint_SwingLimit, PxArticulationJoint, PxReal > SwingLimit;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulationJoint_SwingLimitEnabled, PxArticulationJoint, _Bool, _Bool > SwingLimitEnabled;
		PxRangePropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulationJoint_TwistLimit, PxArticulationJoint, PxReal > TwistLimit;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxArticulationJoint_TwistLimitEnabled, PxArticulationJoint, _Bool, _Bool > TwistLimitEnabled;

		PX_PHYSX_CORE_API PxArticulationJointGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxArticulationJoint*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 12; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		void visitInstanceProperty( TOperator inOperator, PxU32 inPropIdx, PxU32 inStartIndex = 0 ) const
		{
			switch( inPropIdx ) {
				case 0: inOperator( ParentPose, inStartIndex + 0 );break; 
				case 1: inOperator( ChildPose, inStartIndex + 1 );break; 
				case 2: inOperator( TargetOrientation, inStartIndex + 2 );break; 
				case 3: inOperator( TargetVelocity, inStartIndex + 3 );break; 
				case 4: inOperator( Spring, inStartIndex + 4 );break; 
				case 5: inOperator( Damping, inStartIndex + 5 );break; 
				case 6: inOperator( InternalCompliance, inStartIndex + 6 );break; 
				case 7: inOperator( ExternalCompliance, inStartIndex + 7 );break; 
				case 8: inOperator( SwingLimit, inStartIndex + 8 );break; 
				case 9: inOperator( SwingLimitEnabled, inStartIndex + 9 );break; 
				case 10: inOperator( TwistLimit, inStartIndex + 10 );break; 
				case 11: inOperator( TwistLimitEnabled, inStartIndex + 11 );break; 
				default: PX_ASSERT( false ); break;
			}
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( ParentPose, inStartIndex + 0 );; 
			inOperator( ChildPose, inStartIndex + 1 );; 
			inOperator( TargetOrientation, inStartIndex + 2 );; 
			inOperator( TargetVelocity, inStartIndex + 3 );; 
			inOperator( Spring, inStartIndex + 4 );; 
			inOperator( Damping, inStartIndex + 5 );; 
			inOperator( InternalCompliance, inStartIndex + 6 );; 
			inOperator( ExternalCompliance, inStartIndex + 7 );; 
			inOperator( SwingLimit, inStartIndex + 8 );; 
			inOperator( SwingLimitEnabled, inStartIndex + 9 );; 
			inOperator( TwistLimit, inStartIndex + 10 );; 
			inOperator( TwistLimitEnabled, inStartIndex + 11 );; 
			return 12 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxArticulationJoint> { PxArticulationJointGeneratedInfo Info; };

	class PxMeshScale;
	struct PxMeshScaleGeneratedValues
	{
		_Bool IsIdentity;
		PxMeshScale Inverse;
		PxVec3 Scale;
		PxQuat Rotation;
		void PX_PHYSX_CORE_API getValues( const PxMeshScale* inSource );
	};
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxMeshScale, IsIdentity, PxMeshScaleGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxMeshScale, Inverse, PxMeshScaleGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxMeshScale, Scale, PxMeshScaleGeneratedValues)
	DEFINE_PROPERTY_TO_VALUE_STRUCT_MAP( PxMeshScale, Rotation, PxMeshScaleGeneratedValues)
	struct PxMeshScaleGeneratedInfo

	{
		static const char* getClassName() { return "PxMeshScale"; }
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxMeshScale_IsIdentity, PxMeshScale, _Bool > IsIdentity;
		PxReadOnlyPropertyInfo<PX_PROPERTY_INFO_NAME::PxMeshScale_Inverse, PxMeshScale, PxMeshScale > Inverse;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxMeshScale_Scale, PxMeshScale, PxVec3, PxVec3 > Scale;
		PxPropertyInfo<PX_PROPERTY_INFO_NAME::PxMeshScale_Rotation, PxMeshScale, PxQuat, PxQuat > Rotation;

		PX_PHYSX_CORE_API PxMeshScaleGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			return inOperator( (PxMeshScale*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator )
		{
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			return inStartIndex;
		}
		static PxU32 instancePropertyCount() { return 4; }
		static PxU32 totalPropertyCount() { return instancePropertyCount(); }
		template<typename TOperator>
		void visitInstanceProperty( TOperator inOperator, PxU32 inPropIdx, PxU32 inStartIndex = 0 ) const
		{
			switch( inPropIdx ) {
				case 0: inOperator( IsIdentity, inStartIndex + 0 );break; 
				case 1: inOperator( Inverse, inStartIndex + 1 );break; 
				case 2: inOperator( Scale, inStartIndex + 2 );break; 
				case 3: inOperator( Rotation, inStartIndex + 3 );break; 
				default: PX_ASSERT( false ); break;
			}
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( IsIdentity, inStartIndex + 0 );; 
			inOperator( Inverse, inStartIndex + 1 );; 
			inOperator( Scale, inStartIndex + 2 );; 
			inOperator( Rotation, inStartIndex + 3 );; 
			return 4 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxMeshScale> { PxMeshScaleGeneratedInfo Info; };



#undef THERE_IS_NO_INCLUDE_GUARD_HERE_FOR_A_REASON
#undef PX_PROPERTY_INFO_NAME
