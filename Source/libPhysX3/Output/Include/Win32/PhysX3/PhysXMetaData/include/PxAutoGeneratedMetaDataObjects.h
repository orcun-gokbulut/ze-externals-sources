// This code contains NVIDIA Confidential Information and is disclosed to you 
// under a form of NVIDIA software license agreement provided separately to you.
//
// Notice
// NVIDIA Corporation and its licensors retain all intellectual property and
// proprietary rights in and to this software and related documentation and 
// any modifications thereto. Any use, reproduction, disclosure, or 
// distribution of this software and related documentation without an express 
// license agreement from NVIDIA Corporation is strictly prohibited.
// 
// ALL NVIDIA DESIGN SPECIFICATIONS, CODE ARE PROVIDED "AS IS.". NVIDIA MAKES
// NO WARRANTIES, EXPRESSED, IMPLIED, STATUTORY, OR OTHERWISE WITH RESPECT TO
// THE MATERIALS, AND EXPRESSLY DISCLAIMS ALL IMPLIED WARRANTIES OF NONINFRINGEMENT,
// MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE.
//
// Information and code furnished is believed to be accurate and reliable.
// However, NVIDIA Corporation assumes no responsibility for the consequences of use of such
// information or for any infringement of patents or other rights of third parties that may
// result from its use. No license is granted by implication or otherwise under any patent
// or patent rights of NVIDIA Corporation. Details are subject to change without notice.
// This code supersedes and replaces all information previously supplied.
// NVIDIA Corporation products are not authorized for use as critical
// components in life support devices or systems without express written approval of
// NVIDIA Corporation.
//
// Copyright (c) 2008-2011 NVIDIA Corporation. All rights reserved.
// Copyright (c) 2004-2008 AGEIA Technologies, Inc. All rights reserved.
// Copyright (c) 2001-2004 NovodeX AG. All rights reserved.

// This code is auto-generated by the PhysX Clang metadata generator.  Do not edit or be
// prepared for your edits to be quietly ignored next time the clang metadata generator is
// run.  You can find the most recent version of clang metadata generator by contacting
// Chris Nuernberger <chrisn@nvidia.com> or Dilip or Adam.
// The source code for the generate was at one time checked into:
// physx/PhysXMetaDataGenerator/llvm/tools/clang/lib/Frontend/PhysXMetaDataAction.cpp
#define THERE_IS_NO_INCLUDE_GUARD_HERE_FOR_A_REASON

	static PxU32ToName g_PxHeightFieldFormat__EnumConversion[] = {
		{ "eS16_TM", static_cast<PxU32>( PxHeightFieldFormat::eS16_TM ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< PxHeightFieldFormat::Enum > { PxEnumTraits() : NameConversion( g_PxHeightFieldFormat__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	static PxU32ToName g_PxHeightFieldFlag__EnumConversion[] = {
		{ "eNO_BOUNDARY_EDGES", static_cast<PxU32>( PxHeightFieldFlag::eNO_BOUNDARY_EDGES ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< PxHeightFieldFlag::Enum > { PxEnumTraits() : NameConversion( g_PxHeightFieldFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxHeightFieldDesc;
	struct PxHeightFieldDescGeneratedInfo

	{
		static const char* getClassName() { return "PxHeightFieldDesc"; }
		PxReadOnlyPropertyInfo<PxPropertyInfoName::PxHeightFieldDesc_Valid, PxHeightFieldDesc, _Bool > Valid;
		PxPropertyInfo<PxPropertyInfoName::PxHeightFieldDesc_NbRows, PxHeightFieldDesc, unsigned int, unsigned int > NbRows;
		PxPropertyInfo<PxPropertyInfoName::PxHeightFieldDesc_NbColumns, PxHeightFieldDesc, unsigned int, unsigned int > NbColumns;
		PxPropertyInfo<PxPropertyInfoName::PxHeightFieldDesc_Format, PxHeightFieldDesc, PxHeightFieldFormat::Enum, PxHeightFieldFormat::Enum > Format;
		PxPropertyInfo<PxPropertyInfoName::PxHeightFieldDesc_Samples, PxHeightFieldDesc, PxStridedData, PxStridedData > Samples;
		PxPropertyInfo<PxPropertyInfoName::PxHeightFieldDesc_Thickness, PxHeightFieldDesc, float, float > Thickness;
		PxPropertyInfo<PxPropertyInfoName::PxHeightFieldDesc_ConvexEdgeThreshold, PxHeightFieldDesc, float, float > ConvexEdgeThreshold;
		PxPropertyInfo<PxPropertyInfoName::PxHeightFieldDesc_Flags, PxHeightFieldDesc, PxFlags<PxHeightFieldFlag::Enum, PxU16>, PxFlags<PxHeightFieldFlag::Enum, PxU16> > Flags;

		PxHeightFieldDescGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			inOperator( (PxHeightFieldDesc*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator ) const
		{
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			return inStartIndex;
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( Valid, inStartIndex + 0 );
			inOperator( NbRows, inStartIndex + 1 );
			inOperator( NbColumns, inStartIndex + 2 );
			inOperator( Format, inStartIndex + 3 );
			inOperator( Samples, inStartIndex + 4 );
			inOperator( Thickness, inStartIndex + 5 );
			inOperator( ConvexEdgeThreshold, inStartIndex + 6 );
			inOperator( Flags, inStartIndex + 7 );
			return 8 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxHeightFieldDesc> { PxHeightFieldDescGeneratedInfo Info; };

	static PxU32ToName g_PxGeometryType__EnumConversion[] = {
		{ "eSPHERE", static_cast<PxU32>( PxGeometryType::eSPHERE ) },
		{ "ePLANE", static_cast<PxU32>( PxGeometryType::ePLANE ) },
		{ "eCAPSULE", static_cast<PxU32>( PxGeometryType::eCAPSULE ) },
		{ "eBOX", static_cast<PxU32>( PxGeometryType::eBOX ) },
		{ "eCONVEXMESH", static_cast<PxU32>( PxGeometryType::eCONVEXMESH ) },
		{ "eTRIANGLEMESH", static_cast<PxU32>( PxGeometryType::eTRIANGLEMESH ) },
		{ "eHEIGHTFIELD", static_cast<PxU32>( PxGeometryType::eHEIGHTFIELD ) },
		{ "eGEOMETRY_COUNT", static_cast<PxU32>( PxGeometryType::eGEOMETRY_COUNT ) },
		{ "eINVALID", static_cast<PxU32>( PxGeometryType::eINVALID ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< PxGeometryType::Enum > { PxEnumTraits() : NameConversion( g_PxGeometryType__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	static PxU32ToName g_PxShapeFlag__EnumConversion[] = {
		{ "eSIMULATION_SHAPE", static_cast<PxU32>( PxShapeFlag::eSIMULATION_SHAPE ) },
		{ "eSCENE_QUERY_SHAPE", static_cast<PxU32>( PxShapeFlag::eSCENE_QUERY_SHAPE ) },
		{ "eTRIGGER_SHAPE", static_cast<PxU32>( PxShapeFlag::eTRIGGER_SHAPE ) },
		{ "eVISUALIZATION", static_cast<PxU32>( PxShapeFlag::eVISUALIZATION ) },
		{ "ePARTICLE_DRAIN", static_cast<PxU32>( PxShapeFlag::ePARTICLE_DRAIN ) },
		{ "eDEFORMABLE_DRAIN", static_cast<PxU32>( PxShapeFlag::eDEFORMABLE_DRAIN ) },
		{ "eUSE_SWEPT_BOUNDS", static_cast<PxU32>( PxShapeFlag::eUSE_SWEPT_BOUNDS ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< PxShapeFlag::Enum > { PxEnumTraits() : NameConversion( g_PxShapeFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxShape;
	struct PxShapeGeneratedInfo

	{
		static const char* getClassName() { return "PxShape"; }
		PxReadOnlyPropertyInfo<PxPropertyInfoName::PxShape_GeometryType, PxShape, PxGeometryType::Enum > GeometryType;
		PxShapeGeometryProperty Geometry;
		PxReadOnlyPropertyInfo<PxPropertyInfoName::PxShape_Actor, PxShape, PxRigidActor & > Actor;
		PxReadOnlyPropertyInfo<PxPropertyInfoName::PxShape_WorldBounds, PxShape, PxBounds3 > WorldBounds;
		PxPropertyInfo<PxPropertyInfoName::PxShape_LocalPose, PxShape, const PxTransform &, PxTransform > LocalPose;
		PxPropertyInfo<PxPropertyInfoName::PxShape_SimulationFilterData, PxShape, const PxFilterData &, PxFilterData > SimulationFilterData;
		PxPropertyInfo<PxPropertyInfoName::PxShape_QueryFilterData, PxShape, const PxFilterData &, PxFilterData > QueryFilterData;
		PxShapeMaterialsProperty Materials;
		PxPropertyInfo<PxPropertyInfoName::PxShape_ContactOffset, PxShape, PxReal, PxReal > ContactOffset;
		PxPropertyInfo<PxPropertyInfoName::PxShape_RestOffset, PxShape, PxReal, PxReal > RestOffset;
		PxPropertyInfo<PxPropertyInfoName::PxShape_Flags, PxShape, PxShapeFlags, PxShapeFlags > Flags;
		PxPropertyInfo<PxPropertyInfoName::PxShape_Name, PxShape, const char *, const char * > Name;
		PxPropertyInfo<PxPropertyInfoName::PxShape_UserData, PxShape, void *, void * > UserData;

		PxShapeGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			inOperator( (PxShape*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator ) const
		{
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			return inStartIndex;
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( GeometryType, inStartIndex + 0 );
			inOperator( Geometry, inStartIndex + 1 );
			inOperator( Actor, inStartIndex + 2 );
			inOperator( WorldBounds, inStartIndex + 3 );
			inOperator( LocalPose, inStartIndex + 4 );
			inOperator( SimulationFilterData, inStartIndex + 5 );
			inOperator( QueryFilterData, inStartIndex + 6 );
			inOperator( Materials, inStartIndex + 7 );
			inOperator( ContactOffset, inStartIndex + 8 );
			inOperator( RestOffset, inStartIndex + 9 );
			inOperator( Flags, inStartIndex + 10 );
			inOperator( Name, inStartIndex + 11 );
			inOperator( UserData, inStartIndex + 12 );
			return 13 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxShape> { PxShapeGeneratedInfo Info; };

	static PxU32ToName g_PxActorType__EnumConversion[] = {
		{ "eRIGID_STATIC", static_cast<PxU32>( PxActorType::eRIGID_STATIC ) },
		{ "eRIGID_DYNAMIC", static_cast<PxU32>( PxActorType::eRIGID_DYNAMIC ) },
		{ "ePARTICLE_SYSTEM", static_cast<PxU32>( PxActorType::ePARTICLE_SYSTEM ) },
		{ "ePARTICLE_FLUID", static_cast<PxU32>( PxActorType::ePARTICLE_FLUID ) },
		{ "eDEFORMABLE", static_cast<PxU32>( PxActorType::eDEFORMABLE ) },
		{ "eARTICULATION_LINK", static_cast<PxU32>( PxActorType::eARTICULATION_LINK ) },
		{ "eACTOR_COUNT", static_cast<PxU32>( PxActorType::eACTOR_COUNT ) },
		{ "eACTOR_FORCE_DWORD", static_cast<PxU32>( PxActorType::eACTOR_FORCE_DWORD ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< PxActorType::Enum > { PxEnumTraits() : NameConversion( g_PxActorType__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	static PxU32ToName g_PxActorFlag__EnumConversion[] = {
		{ "eVISUALIZATION", static_cast<PxU32>( PxActorFlag::eVISUALIZATION ) },
		{ "eDISABLE_GRAVITY", static_cast<PxU32>( PxActorFlag::eDISABLE_GRAVITY ) },
		{ "eSEND_SLEEP_NOTIFIES", static_cast<PxU32>( PxActorFlag::eSEND_SLEEP_NOTIFIES ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< PxActorFlag::Enum > { PxEnumTraits() : NameConversion( g_PxActorFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxActor;
	struct PxActorGeneratedInfo

	{
		static const char* getClassName() { return "PxActor"; }
		PxReadOnlyPropertyInfo<PxPropertyInfoName::PxActor_ClassName, PxActor, const char * > ClassName;
		PxReadOnlyPropertyInfo<PxPropertyInfoName::PxActor_Type, PxActor, PxActorType::Enum > Type;
		PxReadOnlyPropertyInfo<PxPropertyInfoName::PxActor_RigidStatic, PxActor, const PxRigidStatic * > RigidStatic;
		PxReadOnlyPropertyInfo<PxPropertyInfoName::PxActor_RigidDynamic, PxActor, const PxRigidDynamic * > RigidDynamic;
		PxReadOnlyPropertyInfo<PxPropertyInfoName::PxActor_ParticleSystem, PxActor, const PxParticleSystem * > ParticleSystem;
		PxReadOnlyPropertyInfo<PxPropertyInfoName::PxActor_ParticleFluid, PxActor, const PxParticleFluid * > ParticleFluid;
		PxReadOnlyPropertyInfo<PxPropertyInfoName::PxActor_Deformable, PxActor, const PxDeformable * > Deformable;
		PxReadOnlyPropertyInfo<PxPropertyInfoName::PxActor_ArticulationLink, PxActor, const PxArticulationLink * > ArticulationLink;
		PxReadOnlyPropertyInfo<PxPropertyInfoName::PxActor_Scene, PxActor, PxScene * > Scene;
		PxPropertyInfo<PxPropertyInfoName::PxActor_Name, PxActor, const char *, const char * > Name;
		PxReadOnlyPropertyInfo<PxPropertyInfoName::PxActor_WorldBounds, PxActor, PxBounds3 > WorldBounds;
		PxPropertyInfo<PxPropertyInfoName::PxActor_ActorFlags, PxActor, PxActorFlags, PxActorFlags > ActorFlags;
		PxPropertyInfo<PxPropertyInfoName::PxActor_DominanceGroup, PxActor, PxDominanceGroup, PxDominanceGroup > DominanceGroup;
		PxPropertyInfo<PxPropertyInfoName::PxActor_OwnerClient, PxActor, PxClientID, PxClientID > OwnerClient;
		PxPropertyInfo<PxPropertyInfoName::PxActor_ClientBehaviorBits, PxActor, PxU32, PxU32 > ClientBehaviorBits;
		PxReadOnlyPropertyInfo<PxPropertyInfoName::PxActor_Aggregate, PxActor, PxAggregate * > Aggregate;
		PxPropertyInfo<PxPropertyInfoName::PxActor_UserData, PxActor, void *, void * > UserData;

		PxActorGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			inOperator( (PxActor*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator ) const
		{
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			return inStartIndex;
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( ClassName, inStartIndex + 0 );
			inOperator( Type, inStartIndex + 1 );
			inOperator( RigidStatic, inStartIndex + 2 );
			inOperator( RigidDynamic, inStartIndex + 3 );
			inOperator( ParticleSystem, inStartIndex + 4 );
			inOperator( ParticleFluid, inStartIndex + 5 );
			inOperator( Deformable, inStartIndex + 6 );
			inOperator( ArticulationLink, inStartIndex + 7 );
			inOperator( Scene, inStartIndex + 8 );
			inOperator( Name, inStartIndex + 9 );
			inOperator( WorldBounds, inStartIndex + 10 );
			inOperator( ActorFlags, inStartIndex + 11 );
			inOperator( DominanceGroup, inStartIndex + 12 );
			inOperator( OwnerClient, inStartIndex + 13 );
			inOperator( ClientBehaviorBits, inStartIndex + 14 );
			inOperator( Aggregate, inStartIndex + 15 );
			inOperator( UserData, inStartIndex + 16 );
			return 17 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxActor> { PxActorGeneratedInfo Info; };

	class PxRigidActor;
	struct PxRigidActorGeneratedInfo
		: PxActorGeneratedInfo
	{
		static const char* getClassName() { return "PxRigidActor"; }
		PxReadOnlyPropertyInfo<PxPropertyInfoName::PxRigidActor_ClassName, PxRigidActor, const char * > ClassName;
		PxReadOnlyPropertyInfo<PxPropertyInfoName::PxRigidActor_GlobalPose, PxRigidActor, PxTransform > GlobalPose;
		PxRigidActorShapeCollection Shapes;
		PxReadOnlyCollectionPropertyInfo<PxPropertyInfoName::PxRigidActor_Constraints, PxRigidActor, PxConstraint > Constraints;

		PxRigidActorGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			inOperator( (PxRigidActor*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator ) const
		{
			inOperator( *static_cast<PxActorGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxActorGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxActorGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( ClassName, inStartIndex + 0 );
			inOperator( GlobalPose, inStartIndex + 1 );
			inOperator( Shapes, inStartIndex + 2 );
			inOperator( Constraints, inStartIndex + 3 );
			return 4 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxRigidActor> { PxRigidActorGeneratedInfo Info; };

	class PxRigidStatic;
	struct PxRigidStaticGeneratedInfo
		: PxRigidActorGeneratedInfo
	{
		static const char* getClassName() { return "PxRigidStatic"; }
		PxPropertyInfo<PxPropertyInfoName::PxRigidStatic_GlobalPose, PxRigidStatic, const PxTransform &, PxTransform > GlobalPose;

		PxRigidStaticGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			inOperator( (PxRigidStatic*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator ) const
		{
			inOperator( *static_cast<PxRigidActorGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxRigidActorGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxRigidActorGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( GlobalPose, inStartIndex + 0 );
			return 1 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxRigidStatic> { PxRigidStaticGeneratedInfo Info; };

	class PxRigidBody;
	struct PxRigidBodyGeneratedInfo
		: PxRigidActorGeneratedInfo
	{
		static const char* getClassName() { return "PxRigidBody"; }
		PxPropertyInfo<PxPropertyInfoName::PxRigidBody_CMassLocalPose, PxRigidBody, const PxTransform &, PxTransform > CMassLocalPose;
		PxPropertyInfo<PxPropertyInfoName::PxRigidBody_Mass, PxRigidBody, PxReal, PxReal > Mass;
		PxPropertyInfo<PxPropertyInfoName::PxRigidBody_MassSpaceInertiaTensor, PxRigidBody, const PxVec3 &, PxVec3 > MassSpaceInertiaTensor;
		PxPropertyInfo<PxPropertyInfoName::PxRigidBody_GlobalPose, PxRigidBody, const PxTransform &, PxTransform > GlobalPose;
		PxPropertyInfo<PxPropertyInfoName::PxRigidBody_LinearVelocity, PxRigidBody, const PxVec3 &, PxVec3 > LinearVelocity;
		PxPropertyInfo<PxPropertyInfoName::PxRigidBody_AngularVelocity, PxRigidBody, const PxVec3 &, PxVec3 > AngularVelocity;

		PxRigidBodyGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			inOperator( (PxRigidBody*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator ) const
		{
			inOperator( *static_cast<PxRigidActorGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxRigidActorGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxRigidActorGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( CMassLocalPose, inStartIndex + 0 );
			inOperator( Mass, inStartIndex + 1 );
			inOperator( MassSpaceInertiaTensor, inStartIndex + 2 );
			inOperator( GlobalPose, inStartIndex + 3 );
			inOperator( LinearVelocity, inStartIndex + 4 );
			inOperator( AngularVelocity, inStartIndex + 5 );
			return 6 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxRigidBody> { PxRigidBodyGeneratedInfo Info; };

	static PxU32ToName g_PxRigidDynamicFlag__EnumConversion[] = {
		{ "eKINEMATIC", static_cast<PxU32>( PxRigidDynamicFlag::eKINEMATIC ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< PxRigidDynamicFlag::Enum > { PxEnumTraits() : NameConversion( g_PxRigidDynamicFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxRigidDynamic;
	struct PxRigidDynamicGeneratedInfo
		: PxRigidBodyGeneratedInfo
	{
		static const char* getClassName() { return "PxRigidDynamic"; }
		PxPropertyInfo<PxPropertyInfoName::PxRigidDynamic_LinearDamping, PxRigidDynamic, PxReal, PxReal > LinearDamping;
		PxPropertyInfo<PxPropertyInfoName::PxRigidDynamic_AngularDamping, PxRigidDynamic, PxReal, PxReal > AngularDamping;
		PxPropertyInfo<PxPropertyInfoName::PxRigidDynamic_MaxAngularVelocity, PxRigidDynamic, PxReal, PxReal > MaxAngularVelocity;
		PxReadOnlyPropertyInfo<PxPropertyInfoName::PxRigidDynamic_Sleeping, PxRigidDynamic, _Bool > Sleeping;
		PxPropertyInfo<PxPropertyInfoName::PxRigidDynamic_SleepEnergyThreshold, PxRigidDynamic, PxReal, PxReal > SleepEnergyThreshold;
		PxRangePropertyInfo<PxPropertyInfoName::PxRigidDynamic_SolverIterationCounts, PxRigidDynamic, PxU32 > SolverIterationCounts;
		PxPropertyInfo<PxPropertyInfoName::PxRigidDynamic_ContactReportThreshold, PxRigidDynamic, PxReal, PxReal > ContactReportThreshold;
		PxPropertyInfo<PxPropertyInfoName::PxRigidDynamic_RigidDynamicFlags, PxRigidDynamic, PxRigidDynamicFlags, PxRigidDynamicFlags > RigidDynamicFlags;

		PxRigidDynamicGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			inOperator( (PxRigidDynamic*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator ) const
		{
			inOperator( *static_cast<PxRigidBodyGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxRigidBodyGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxRigidBodyGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( LinearDamping, inStartIndex + 0 );
			inOperator( AngularDamping, inStartIndex + 1 );
			inOperator( MaxAngularVelocity, inStartIndex + 2 );
			inOperator( Sleeping, inStartIndex + 3 );
			inOperator( SleepEnergyThreshold, inStartIndex + 4 );
			inOperator( SolverIterationCounts, inStartIndex + 5 );
			inOperator( ContactReportThreshold, inStartIndex + 6 );
			inOperator( RigidDynamicFlags, inStartIndex + 7 );
			return 8 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxRigidDynamic> { PxRigidDynamicGeneratedInfo Info; };

	static PxU32ToName g_PxConstraintFlag__TypeConversion[] = {
		{ "eBROKEN", static_cast<PxU32>( PxConstraintFlag::eBROKEN ) },
		{ "ePROJECTION", static_cast<PxU32>( PxConstraintFlag::ePROJECTION ) },
		{ "eCOLLISION_ENABLED", static_cast<PxU32>( PxConstraintFlag::eCOLLISION_ENABLED ) },
		{ "eREPORTING", static_cast<PxU32>( PxConstraintFlag::eREPORTING ) },
		{ "eVISUALIZATION", static_cast<PxU32>( PxConstraintFlag::eVISUALIZATION ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< PxConstraintFlag::Type > { PxEnumTraits() : NameConversion( g_PxConstraintFlag__TypeConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxConstraint;
	struct PxConstraintGeneratedInfo

	{
		static const char* getClassName() { return "PxConstraint"; }
		PxReadOnlyPropertyInfo<PxPropertyInfoName::PxConstraint_ClassName, PxConstraint, const char * > ClassName;
		PxReadOnlyPropertyInfo<PxPropertyInfoName::PxConstraint_Scene, PxConstraint, PxScene * > Scene;
		PxRangePropertyInfo<PxPropertyInfoName::PxConstraint_Actors, PxConstraint, PxRigidActor * > Actors;
		PxPropertyInfo<PxPropertyInfoName::PxConstraint_Flags, PxConstraint, PxConstraintFlags, PxConstraintFlags > Flags;
		PxRangePropertyInfo<PxPropertyInfoName::PxConstraint_BreakImpulse, PxConstraint, PxReal > BreakImpulse;

		PxConstraintGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			inOperator( (PxConstraint*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator ) const
		{
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			return inStartIndex;
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( ClassName, inStartIndex + 0 );
			inOperator( Scene, inStartIndex + 1 );
			inOperator( Actors, inStartIndex + 2 );
			inOperator( Flags, inStartIndex + 3 );
			inOperator( BreakImpulse, inStartIndex + 4 );
			return 5 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxConstraint> { PxConstraintGeneratedInfo Info; };

	class PxArticulation;
	struct PxArticulationGeneratedInfo

	{
		static const char* getClassName() { return "PxArticulation"; }
		PxReadOnlyPropertyInfo<PxPropertyInfoName::PxArticulation_Scene, PxArticulation, PxScene * > Scene;
		PxPropertyInfo<PxPropertyInfoName::PxArticulation_MaxProjectionIterations, PxArticulation, PxU32, PxU32 > MaxProjectionIterations;
		PxPropertyInfo<PxPropertyInfoName::PxArticulation_SeparationTolerance, PxArticulation, PxReal, PxReal > SeparationTolerance;
		PxPropertyInfo<PxPropertyInfoName::PxArticulation_InternalDriveIterations, PxArticulation, PxU32, PxU32 > InternalDriveIterations;
		PxPropertyInfo<PxPropertyInfoName::PxArticulation_ExternalDriveIterations, PxArticulation, PxU32, PxU32 > ExternalDriveIterations;
		PxArticulationLinkCollectionProp Links;
		PxPropertyInfo<PxPropertyInfoName::PxArticulation_Name, PxArticulation, const char *, const char * > Name;
		PxReadOnlyPropertyInfo<PxPropertyInfoName::PxArticulation_WorldBounds, PxArticulation, PxBounds3 > WorldBounds;
		PxReadOnlyPropertyInfo<PxPropertyInfoName::PxArticulation_Aggregate, PxArticulation, PxAggregate * > Aggregate;
		PxPropertyInfo<PxPropertyInfoName::PxArticulation_UserData, PxArticulation, void *, void * > UserData;

		PxArticulationGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			inOperator( (PxArticulation*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator ) const
		{
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			return inStartIndex;
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( Scene, inStartIndex + 0 );
			inOperator( MaxProjectionIterations, inStartIndex + 1 );
			inOperator( SeparationTolerance, inStartIndex + 2 );
			inOperator( InternalDriveIterations, inStartIndex + 3 );
			inOperator( ExternalDriveIterations, inStartIndex + 4 );
			inOperator( Links, inStartIndex + 5 );
			inOperator( Name, inStartIndex + 6 );
			inOperator( WorldBounds, inStartIndex + 7 );
			inOperator( Aggregate, inStartIndex + 8 );
			inOperator( UserData, inStartIndex + 9 );
			return 10 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxArticulation> { PxArticulationGeneratedInfo Info; };

	static PxU32ToName g_PxMaterialFlag__EnumConversion[] = {
		{ "eANISOTROPIC", static_cast<PxU32>( PxMaterialFlag::eANISOTROPIC ) },
		{ "eDISABLE_FRICTION", static_cast<PxU32>( PxMaterialFlag::eDISABLE_FRICTION ) },
		{ "eDISABLE_STRONG_FRICTION", static_cast<PxU32>( PxMaterialFlag::eDISABLE_STRONG_FRICTION ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< PxMaterialFlag::Enum > { PxEnumTraits() : NameConversion( g_PxMaterialFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	static PxU32ToName g_PxCombineMode__EnumConversion[] = {
		{ "eAVERAGE", static_cast<PxU32>( PxCombineMode::eAVERAGE ) },
		{ "eMIN", static_cast<PxU32>( PxCombineMode::eMIN ) },
		{ "eMULTIPLY", static_cast<PxU32>( PxCombineMode::eMULTIPLY ) },
		{ "eMAX", static_cast<PxU32>( PxCombineMode::eMAX ) },
		{ "eN_VALUES", static_cast<PxU32>( PxCombineMode::eN_VALUES ) },
		{ "ePAD_32", static_cast<PxU32>( PxCombineMode::ePAD_32 ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< PxCombineMode::Enum > { PxEnumTraits() : NameConversion( g_PxCombineMode__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxMaterial;
	struct PxMaterialGeneratedInfo

	{
		static const char* getClassName() { return "PxMaterial"; }
		PxPropertyInfo<PxPropertyInfoName::PxMaterial_DynamicFriction, PxMaterial, PxReal, PxReal > DynamicFriction;
		PxPropertyInfo<PxPropertyInfoName::PxMaterial_StaticFriction, PxMaterial, PxReal, PxReal > StaticFriction;
		PxPropertyInfo<PxPropertyInfoName::PxMaterial_Restitution, PxMaterial, PxReal, PxReal > Restitution;
		PxPropertyInfo<PxPropertyInfoName::PxMaterial_DynamicFrictionV, PxMaterial, PxReal, PxReal > DynamicFrictionV;
		PxPropertyInfo<PxPropertyInfoName::PxMaterial_StaticFrictionV, PxMaterial, PxReal, PxReal > StaticFrictionV;
		PxPropertyInfo<PxPropertyInfoName::PxMaterial_DirOfAnisotropy, PxMaterial, const PxVec3 &, PxVec3 > DirOfAnisotropy;
		PxPropertyInfo<PxPropertyInfoName::PxMaterial_Flags, PxMaterial, PxMaterialFlags, PxMaterialFlags > Flags;
		PxPropertyInfo<PxPropertyInfoName::PxMaterial_FrictionCombineMode, PxMaterial, PxCombineMode::Enum, PxCombineMode::Enum > FrictionCombineMode;
		PxPropertyInfo<PxPropertyInfoName::PxMaterial_RestitutionCombineMode, PxMaterial, PxCombineMode::Enum, PxCombineMode::Enum > RestitutionCombineMode;
		PxPropertyInfo<PxPropertyInfoName::PxMaterial_UserData, PxMaterial, void *, void * > UserData;

		PxMaterialGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			inOperator( (PxMaterial*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator ) const
		{
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			return inStartIndex;
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( DynamicFriction, inStartIndex + 0 );
			inOperator( StaticFriction, inStartIndex + 1 );
			inOperator( Restitution, inStartIndex + 2 );
			inOperator( DynamicFrictionV, inStartIndex + 3 );
			inOperator( StaticFrictionV, inStartIndex + 4 );
			inOperator( DirOfAnisotropy, inStartIndex + 5 );
			inOperator( Flags, inStartIndex + 6 );
			inOperator( FrictionCombineMode, inStartIndex + 7 );
			inOperator( RestitutionCombineMode, inStartIndex + 8 );
			inOperator( UserData, inStartIndex + 9 );
			return 10 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxMaterial> { PxMaterialGeneratedInfo Info; };

	static PxU32ToName g_PxSceneFlag__EnumConversion[] = {
		{ "eDISABLE_SSE", static_cast<PxU32>( PxSceneFlag::eDISABLE_SSE ) },
		{ "eENABLE_ACTIVETRANSFORMS", static_cast<PxU32>( PxSceneFlag::eENABLE_ACTIVETRANSFORMS ) },
		{ "eENABLE_SWEPT_INTEGRATION", static_cast<PxU32>( PxSceneFlag::eENABLE_SWEPT_INTEGRATION ) },
		{ "eADAPTIVE_FORCE", static_cast<PxU32>( PxSceneFlag::eADAPTIVE_FORCE ) },
		{ "eENABLE_KINEMATIC_STATIC_PAIRS", static_cast<PxU32>( PxSceneFlag::eENABLE_KINEMATIC_STATIC_PAIRS ) },
		{ "eENABLE_KINEMATIC_PAIRS", static_cast<PxU32>( PxSceneFlag::eENABLE_KINEMATIC_PAIRS ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< PxSceneFlag::Enum > { PxEnumTraits() : NameConversion( g_PxSceneFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	static PxU32ToName g_PxActorTypeSelectionFlag__EnumConversion[] = {
		{ "eRIGID_STATIC", static_cast<PxU32>( PxActorTypeSelectionFlag::eRIGID_STATIC ) },
		{ "eRIGID_DYNAMIC", static_cast<PxU32>( PxActorTypeSelectionFlag::eRIGID_DYNAMIC ) },
		{ "ePARTICLE_SYSTEM", static_cast<PxU32>( PxActorTypeSelectionFlag::ePARTICLE_SYSTEM ) },
		{ "ePARTICLE_FLUID", static_cast<PxU32>( PxActorTypeSelectionFlag::ePARTICLE_FLUID ) },
		{ "eDEFORMABLE", static_cast<PxU32>( PxActorTypeSelectionFlag::eDEFORMABLE ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< PxActorTypeSelectionFlag::Enum > { PxEnumTraits() : NameConversion( g_PxActorTypeSelectionFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxScene;
	struct PxSceneGeneratedInfo

	{
		static const char* getClassName() { return "PxScene"; }
		PxReadOnlyPropertyInfo<PxPropertyInfoName::PxScene_Flags, PxScene, PxSceneFlags > Flags;
		PxPropertyInfo<PxPropertyInfoName::PxScene_Gravity, PxScene, const PxVec3 &, PxVec3 > Gravity;
		PxReadOnlyFilteredCollectionPropertyInfo<PxPropertyInfoName::PxScene_Actors, PxScene, PxActor, PxActorTypeSelectionFlags > Actors;
		PxReadOnlyCollectionPropertyInfo<PxPropertyInfoName::PxScene_Articulations, PxScene, PxArticulation > Articulations;
		PxReadOnlyCollectionPropertyInfo<PxPropertyInfoName::PxScene_Constraints, PxScene, PxConstraint > Constraints;
		PxReadOnlyCollectionPropertyInfo<PxPropertyInfoName::PxScene_Attachments, PxScene, PxAttachment > Attachments;
		PxIndexedPropertyInfo<PxPropertyInfoName::PxScene_ClientBehaviorBits, PxScene, PxClientID, PxU32 > ClientBehaviorBits;
		PxPropertyInfo<PxPropertyInfoName::PxScene_ContactModifyCallback, PxScene, PxContactModifyCallback *, PxContactModifyCallback * > ContactModifyCallback;
		PxReadOnlyPropertyInfo<PxPropertyInfoName::PxScene_FilterShaderData, PxScene, const void * > FilterShaderData;
		PxReadOnlyPropertyInfo<PxPropertyInfoName::PxScene_FilterShaderDataSize, PxScene, PxU32 > FilterShaderDataSize;
		PxReadOnlyPropertyInfo<PxPropertyInfoName::PxScene_FilterShader, PxScene, PxSimulationFilterShader > FilterShader;
		PxReadOnlyPropertyInfo<PxPropertyInfoName::PxScene_FilterCallback, PxScene, PxSimulationFilterCallback * > FilterCallback;
		PxPropertyInfo<PxPropertyInfoName::PxScene_DynamicTreeRebuildRateHint, PxScene, PxU32, PxU32 > DynamicTreeRebuildRateHint;
		PxPropertyInfo<PxPropertyInfoName::PxScene_SolverBatchSize, PxScene, PxU32, PxU32 > SolverBatchSize;
		PxPropertyInfo<PxPropertyInfoName::PxScene_VisualizationCullingBox, PxScene, const PxBounds3 &, const PxBounds3 & > VisualizationCullingBox;
		PxReadOnlyPropertyInfo<PxPropertyInfoName::PxScene_TaskManager, PxScene, physx::pxtask::TaskManager * > TaskManager;
		PxPropertyInfo<PxPropertyInfoName::PxScene_UserData, PxScene, void *, void * > UserData;

		PxSceneGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			inOperator( (PxScene*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator ) const
		{
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			return inStartIndex;
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( Flags, inStartIndex + 0 );
			inOperator( Gravity, inStartIndex + 1 );
			inOperator( Actors, inStartIndex + 2 );
			inOperator( Articulations, inStartIndex + 3 );
			inOperator( Constraints, inStartIndex + 4 );
			inOperator( Attachments, inStartIndex + 5 );
			inOperator( ClientBehaviorBits, inStartIndex + 6 );
			inOperator( ContactModifyCallback, inStartIndex + 7 );
			inOperator( FilterShaderData, inStartIndex + 8 );
			inOperator( FilterShaderDataSize, inStartIndex + 9 );
			inOperator( FilterShader, inStartIndex + 10 );
			inOperator( FilterCallback, inStartIndex + 11 );
			inOperator( DynamicTreeRebuildRateHint, inStartIndex + 12 );
			inOperator( SolverBatchSize, inStartIndex + 13 );
			inOperator( VisualizationCullingBox, inStartIndex + 14 );
			inOperator( TaskManager, inStartIndex + 15 );
			inOperator( UserData, inStartIndex + 16 );
			return 17 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxScene> { PxSceneGeneratedInfo Info; };

	class PxTolerancesScale;
	struct PxTolerancesScaleGeneratedInfo

	{
		static const char* getClassName() { return "PxTolerancesScale"; }
		PxReadOnlyPropertyInfo<PxPropertyInfoName::PxTolerancesScale_Valid, PxTolerancesScale, _Bool > Valid;
		PxPropertyInfo<PxPropertyInfoName::PxTolerancesScale_Length, PxTolerancesScale, float, float > Length;
		PxPropertyInfo<PxPropertyInfoName::PxTolerancesScale_Mass, PxTolerancesScale, float, float > Mass;
		PxPropertyInfo<PxPropertyInfoName::PxTolerancesScale_Speed, PxTolerancesScale, float, float > Speed;

		PxTolerancesScaleGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			inOperator( (PxTolerancesScale*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator ) const
		{
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			return inStartIndex;
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( Valid, inStartIndex + 0 );
			inOperator( Length, inStartIndex + 1 );
			inOperator( Mass, inStartIndex + 2 );
			inOperator( Speed, inStartIndex + 3 );
			return 4 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxTolerancesScale> { PxTolerancesScaleGeneratedInfo Info; };

	class PxGeometry;
	struct PxGeometryGeneratedInfo

	{
		static const char* getClassName() { return "PxGeometry"; }
		PxReadOnlyPropertyInfo<PxPropertyInfoName::PxGeometry_Type, PxGeometry, PxGeometryType::Enum > Type;

		PxGeometryGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			inOperator( (PxGeometry*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator ) const
		{
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			return inStartIndex;
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( Type, inStartIndex + 0 );
			return 1 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxGeometry> { PxGeometryGeneratedInfo Info; };

	class PxPhysics;
	struct PxPhysicsGeneratedInfo

	{
		static const char* getClassName() { return "PxPhysics"; }
		PxFactoryCollectionPropertyInfo<PxPropertyInfoName::PxPhysics_Scenes, PxPhysics, PxScene, const PxSceneDesc & > Scenes;
		PxFactoryCollectionPropertyInfo<PxPropertyInfoName::PxPhysics_Materials, PxPhysics, PxMaterial, class PxMaterialDesc const & > Materials;
		PxFactoryCollectionPropertyInfo<PxPropertyInfoName::PxPhysics_TriangleMeshes, PxPhysics, PxTriangleMesh, const PxStream & > TriangleMeshes;
		PxFactoryCollectionPropertyInfo<PxPropertyInfoName::PxPhysics_HeightFields, PxPhysics, PxHeightField, const PxHeightFieldDesc & > HeightFields;
		PxFactoryCollectionPropertyInfo<PxPropertyInfoName::PxPhysics_ConvexMeshes, PxPhysics, PxConvexMesh, const PxStream & > ConvexMeshes;
		PxFactoryCollectionPropertyInfo<PxPropertyInfoName::PxPhysics_DeformableMeshes, PxPhysics, PxDeformableMesh, const PxStream & > DeformableMeshes;
		PxReadOnlyPropertyInfo<PxPropertyInfoName::PxPhysics_TolerancesScale, PxPhysics, const PxTolerancesScale & > TolerancesScale;

		PxPhysicsGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			inOperator( (PxPhysics*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator ) const
		{
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			return inStartIndex;
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( Scenes, inStartIndex + 0 );
			inOperator( Materials, inStartIndex + 1 );
			inOperator( TriangleMeshes, inStartIndex + 2 );
			inOperator( HeightFields, inStartIndex + 3 );
			inOperator( ConvexMeshes, inStartIndex + 4 );
			inOperator( DeformableMeshes, inStartIndex + 5 );
			inOperator( TolerancesScale, inStartIndex + 6 );
			return 7 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxPhysics> { PxPhysicsGeneratedInfo Info; };

	class PxArticulationLink;
	struct PxArticulationLinkGeneratedInfo
		: PxRigidBodyGeneratedInfo
	{
		static const char* getClassName() { return "PxArticulationLink"; }
		PxReadOnlyPropertyInfo<PxPropertyInfoName::PxArticulationLink_Articulation, PxArticulationLink, PxArticulation & > Articulation;
		PxReadOnlyPropertyInfo<PxPropertyInfoName::PxArticulationLink_InboundJoint, PxArticulationLink, PxArticulationJoint * > InboundJoint;
		PxReadOnlyCollectionPropertyInfo<PxPropertyInfoName::PxArticulationLink_Children, PxArticulationLink, PxArticulationLink > Children;

		PxArticulationLinkGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			inOperator( (PxArticulationLink*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator ) const
		{
			inOperator( *static_cast<PxRigidBodyGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxRigidBodyGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxRigidBodyGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( Articulation, inStartIndex + 0 );
			inOperator( InboundJoint, inStartIndex + 1 );
			inOperator( Children, inStartIndex + 2 );
			return 3 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxArticulationLink> { PxArticulationLinkGeneratedInfo Info; };

	class PxSphereGeometry;
	struct PxSphereGeometryGeneratedInfo
		: PxGeometryGeneratedInfo
	{
		static const char* getClassName() { return "PxSphereGeometry"; }
		PxReadOnlyPropertyInfo<PxPropertyInfoName::PxSphereGeometry_Valid, PxSphereGeometry, _Bool > Valid;
		PxPropertyInfo<PxPropertyInfoName::PxSphereGeometry_Radius, PxSphereGeometry, float, float > Radius;

		PxSphereGeometryGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			inOperator( (PxSphereGeometry*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator ) const
		{
			inOperator( *static_cast<PxGeometryGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxGeometryGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxGeometryGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( Valid, inStartIndex + 0 );
			inOperator( Radius, inStartIndex + 1 );
			return 2 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxSphereGeometry> { PxSphereGeometryGeneratedInfo Info; };

	class PxBoxGeometry;
	struct PxBoxGeometryGeneratedInfo
		: PxGeometryGeneratedInfo
	{
		static const char* getClassName() { return "PxBoxGeometry"; }
		PxReadOnlyPropertyInfo<PxPropertyInfoName::PxBoxGeometry_Valid, PxBoxGeometry, _Bool > Valid;
		PxPropertyInfo<PxPropertyInfoName::PxBoxGeometry_HalfExtents, PxBoxGeometry, PxVec3, PxVec3 > HalfExtents;

		PxBoxGeometryGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			inOperator( (PxBoxGeometry*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator ) const
		{
			inOperator( *static_cast<PxGeometryGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxGeometryGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxGeometryGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( Valid, inStartIndex + 0 );
			inOperator( HalfExtents, inStartIndex + 1 );
			return 2 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxBoxGeometry> { PxBoxGeometryGeneratedInfo Info; };

	class PxCapsuleGeometry;
	struct PxCapsuleGeometryGeneratedInfo
		: PxGeometryGeneratedInfo
	{
		static const char* getClassName() { return "PxCapsuleGeometry"; }
		PxReadOnlyPropertyInfo<PxPropertyInfoName::PxCapsuleGeometry_Valid, PxCapsuleGeometry, _Bool > Valid;
		PxPropertyInfo<PxPropertyInfoName::PxCapsuleGeometry_Radius, PxCapsuleGeometry, float, float > Radius;
		PxPropertyInfo<PxPropertyInfoName::PxCapsuleGeometry_HalfHeight, PxCapsuleGeometry, float, float > HalfHeight;

		PxCapsuleGeometryGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			inOperator( (PxCapsuleGeometry*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator ) const
		{
			inOperator( *static_cast<PxGeometryGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxGeometryGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxGeometryGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( Valid, inStartIndex + 0 );
			inOperator( Radius, inStartIndex + 1 );
			inOperator( HalfHeight, inStartIndex + 2 );
			return 3 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxCapsuleGeometry> { PxCapsuleGeometryGeneratedInfo Info; };

	class PxPlaneGeometry;
	struct PxPlaneGeometryGeneratedInfo
		: PxGeometryGeneratedInfo
	{
		static const char* getClassName() { return "PxPlaneGeometry"; }
		PxReadOnlyPropertyInfo<PxPropertyInfoName::PxPlaneGeometry_Valid, PxPlaneGeometry, _Bool > Valid;

		PxPlaneGeometryGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			inOperator( (PxPlaneGeometry*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator ) const
		{
			inOperator( *static_cast<PxGeometryGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxGeometryGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxGeometryGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( Valid, inStartIndex + 0 );
			return 1 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxPlaneGeometry> { PxPlaneGeometryGeneratedInfo Info; };

	class PxConvexMeshGeometry;
	struct PxConvexMeshGeometryGeneratedInfo
		: PxGeometryGeneratedInfo
	{
		static const char* getClassName() { return "PxConvexMeshGeometry"; }
		PxReadOnlyPropertyInfo<PxPropertyInfoName::PxConvexMeshGeometry_Valid, PxConvexMeshGeometry, _Bool > Valid;
		PxPropertyInfo<PxPropertyInfoName::PxConvexMeshGeometry_Scale, PxConvexMeshGeometry, PxMeshScale, PxMeshScale > Scale;
		PxPropertyInfo<PxPropertyInfoName::PxConvexMeshGeometry_ConvexMesh, PxConvexMeshGeometry, PxConvexMesh *, PxConvexMesh * > ConvexMesh;

		PxConvexMeshGeometryGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			inOperator( (PxConvexMeshGeometry*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator ) const
		{
			inOperator( *static_cast<PxGeometryGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxGeometryGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxGeometryGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( Valid, inStartIndex + 0 );
			inOperator( Scale, inStartIndex + 1 );
			inOperator( ConvexMesh, inStartIndex + 2 );
			return 3 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxConvexMeshGeometry> { PxConvexMeshGeometryGeneratedInfo Info; };

	static PxU32ToName g_PxMeshGeometryFlag__EnumConversion[] = {
		{ "eSMOOTH_SPHERE_COLLISIONS", static_cast<PxU32>( PxMeshGeometryFlag::eSMOOTH_SPHERE_COLLISIONS ) },
		{ "eDOUBLE_SIDED", static_cast<PxU32>( PxMeshGeometryFlag::eDOUBLE_SIDED ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< PxMeshGeometryFlag::Enum > { PxEnumTraits() : NameConversion( g_PxMeshGeometryFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxTriangleMeshGeometry;
	struct PxTriangleMeshGeometryGeneratedInfo
		: PxGeometryGeneratedInfo
	{
		static const char* getClassName() { return "PxTriangleMeshGeometry"; }
		PxReadOnlyPropertyInfo<PxPropertyInfoName::PxTriangleMeshGeometry_Valid, PxTriangleMeshGeometry, _Bool > Valid;
		PxPropertyInfo<PxPropertyInfoName::PxTriangleMeshGeometry_Scale, PxTriangleMeshGeometry, PxMeshScale, PxMeshScale > Scale;
		PxPropertyInfo<PxPropertyInfoName::PxTriangleMeshGeometry_MeshFlags, PxTriangleMeshGeometry, PxFlags<PxMeshGeometryFlag::Enum, PxU8>, PxFlags<PxMeshGeometryFlag::Enum, PxU8> > MeshFlags;
		PxPropertyInfo<PxPropertyInfoName::PxTriangleMeshGeometry_TriangleMesh, PxTriangleMeshGeometry, PxTriangleMesh *, PxTriangleMesh * > TriangleMesh;

		PxTriangleMeshGeometryGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			inOperator( (PxTriangleMeshGeometry*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator ) const
		{
			inOperator( *static_cast<PxGeometryGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxGeometryGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxGeometryGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( Valid, inStartIndex + 0 );
			inOperator( Scale, inStartIndex + 1 );
			inOperator( MeshFlags, inStartIndex + 2 );
			inOperator( TriangleMesh, inStartIndex + 3 );
			return 4 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxTriangleMeshGeometry> { PxTriangleMeshGeometryGeneratedInfo Info; };

	class PxHeightFieldGeometry;
	struct PxHeightFieldGeometryGeneratedInfo
		: PxGeometryGeneratedInfo
	{
		static const char* getClassName() { return "PxHeightFieldGeometry"; }
		PxReadOnlyPropertyInfo<PxPropertyInfoName::PxHeightFieldGeometry_Valid, PxHeightFieldGeometry, _Bool > Valid;
		PxPropertyInfo<PxPropertyInfoName::PxHeightFieldGeometry_HeightField, PxHeightFieldGeometry, PxHeightField *, PxHeightField * > HeightField;
		PxPropertyInfo<PxPropertyInfoName::PxHeightFieldGeometry_HeightScale, PxHeightFieldGeometry, float, float > HeightScale;
		PxPropertyInfo<PxPropertyInfoName::PxHeightFieldGeometry_RowScale, PxHeightFieldGeometry, float, float > RowScale;
		PxPropertyInfo<PxPropertyInfoName::PxHeightFieldGeometry_ColumnScale, PxHeightFieldGeometry, float, float > ColumnScale;
		PxPropertyInfo<PxPropertyInfoName::PxHeightFieldGeometry_HeightFieldFlags, PxHeightFieldGeometry, PxFlags<PxMeshGeometryFlag::Enum, PxU8>, PxFlags<PxMeshGeometryFlag::Enum, PxU8> > HeightFieldFlags;

		PxHeightFieldGeometryGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			inOperator( (PxHeightFieldGeometry*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator ) const
		{
			inOperator( *static_cast<PxGeometryGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxGeometryGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxGeometryGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( Valid, inStartIndex + 0 );
			inOperator( HeightField, inStartIndex + 1 );
			inOperator( HeightScale, inStartIndex + 2 );
			inOperator( RowScale, inStartIndex + 3 );
			inOperator( ColumnScale, inStartIndex + 4 );
			inOperator( HeightFieldFlags, inStartIndex + 5 );
			return 6 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxHeightFieldGeometry> { PxHeightFieldGeometryGeneratedInfo Info; };

	class PxArticulationJoint;
	struct PxArticulationJointGeneratedInfo

	{
		static const char* getClassName() { return "PxArticulationJoint"; }
		PxPropertyInfo<PxPropertyInfoName::PxArticulationJoint_ParentPose, PxArticulationJoint, const PxTransform &, PxTransform > ParentPose;
		PxPropertyInfo<PxPropertyInfoName::PxArticulationJoint_ChildPose, PxArticulationJoint, const PxTransform &, PxTransform > ChildPose;
		PxPropertyInfo<PxPropertyInfoName::PxArticulationJoint_TargetOrientation, PxArticulationJoint, const PxQuat &, PxQuat > TargetOrientation;
		PxPropertyInfo<PxPropertyInfoName::PxArticulationJoint_TargetVelocity, PxArticulationJoint, const PxVec3 &, PxVec3 > TargetVelocity;
		PxPropertyInfo<PxPropertyInfoName::PxArticulationJoint_Spring, PxArticulationJoint, PxReal, PxReal > Spring;
		PxPropertyInfo<PxPropertyInfoName::PxArticulationJoint_Damping, PxArticulationJoint, PxReal, PxReal > Damping;
		PxPropertyInfo<PxPropertyInfoName::PxArticulationJoint_InternalCompliance, PxArticulationJoint, PxReal, PxReal > InternalCompliance;
		PxPropertyInfo<PxPropertyInfoName::PxArticulationJoint_ExternalCompliance, PxArticulationJoint, PxReal, PxReal > ExternalCompliance;
		PxRangePropertyInfo<PxPropertyInfoName::PxArticulationJoint_SwingLimit, PxArticulationJoint, PxReal > SwingLimit;
		PxPropertyInfo<PxPropertyInfoName::PxArticulationJoint_SwingLimitEnabled, PxArticulationJoint, _Bool, _Bool > SwingLimitEnabled;
		PxRangePropertyInfo<PxPropertyInfoName::PxArticulationJoint_TwistLimit, PxArticulationJoint, PxReal > TwistLimit;
		PxPropertyInfo<PxPropertyInfoName::PxArticulationJoint_TwistLimitEnabled, PxArticulationJoint, _Bool, _Bool > TwistLimitEnabled;

		PxArticulationJointGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			inOperator( (PxArticulationJoint*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator ) const
		{
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			return inStartIndex;
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( ParentPose, inStartIndex + 0 );
			inOperator( ChildPose, inStartIndex + 1 );
			inOperator( TargetOrientation, inStartIndex + 2 );
			inOperator( TargetVelocity, inStartIndex + 3 );
			inOperator( Spring, inStartIndex + 4 );
			inOperator( Damping, inStartIndex + 5 );
			inOperator( InternalCompliance, inStartIndex + 6 );
			inOperator( ExternalCompliance, inStartIndex + 7 );
			inOperator( SwingLimit, inStartIndex + 8 );
			inOperator( SwingLimitEnabled, inStartIndex + 9 );
			inOperator( TwistLimit, inStartIndex + 10 );
			inOperator( TwistLimitEnabled, inStartIndex + 11 );
			return 12 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxArticulationJoint> { PxArticulationJointGeneratedInfo Info; };

	class PxMeshScale;
	struct PxMeshScaleGeneratedInfo

	{
		static const char* getClassName() { return "PxMeshScale"; }
		PxReadOnlyPropertyInfo<PxPropertyInfoName::PxMeshScale_Identity, PxMeshScale, _Bool > Identity;
		PxReadOnlyPropertyInfo<PxPropertyInfoName::PxMeshScale_Inverse, PxMeshScale, PxMeshScale > Inverse;
		PxPropertyInfo<PxPropertyInfoName::PxMeshScale_Scale, PxMeshScale, PxVec3, PxVec3 > Scale;
		PxPropertyInfo<PxPropertyInfoName::PxMeshScale_Rotation, PxMeshScale, PxQuat, PxQuat > Rotation;

		PxMeshScaleGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			inOperator( (PxMeshScale*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator ) const
		{
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			return inStartIndex;
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( Identity, inStartIndex + 0 );
			inOperator( Inverse, inStartIndex + 1 );
			inOperator( Scale, inStartIndex + 2 );
			inOperator( Rotation, inStartIndex + 3 );
			return 4 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxMeshScale> { PxMeshScaleGeneratedInfo Info; };

	static PxU32ToName g_PxJointType__EnumConversion[] = {
		{ "eD6", static_cast<PxU32>( PxJointType::eD6 ) },
		{ "eDISTANCE", static_cast<PxU32>( PxJointType::eDISTANCE ) },
		{ "eFIXED", static_cast<PxU32>( PxJointType::eFIXED ) },
		{ "ePRISMATIC", static_cast<PxU32>( PxJointType::ePRISMATIC ) },
		{ "eREVOLUTE", static_cast<PxU32>( PxJointType::eREVOLUTE ) },
		{ "eSPHERICAL", static_cast<PxU32>( PxJointType::eSPHERICAL ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< PxJointType::Enum > { PxEnumTraits() : NameConversion( g_PxJointType__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxJoint;
	struct PxJointGeneratedInfo

	{
		static const char* getClassName() { return "PxJoint"; }
		PxRangePropertyInfo<PxPropertyInfoName::PxJoint_Actors, PxJoint, PxRigidActor * > Actors;
		PxIndexedPropertyInfo<PxPropertyInfoName::PxJoint_LocalPose, PxJoint, PxU32, PxTransform > LocalPose;
		PxRangePropertyInfo<PxPropertyInfoName::PxJoint_BreakForce, PxJoint, PxReal > BreakForce;
		PxPropertyInfo<PxPropertyInfoName::PxJoint_ConstraintFlags, PxJoint, PxConstraintFlags, PxConstraintFlags > ConstraintFlags;
		PxPropertyInfo<PxPropertyInfoName::PxJoint_Name, PxJoint, const char *, const char * > Name;
		PxReadOnlyPropertyInfo<PxPropertyInfoName::PxJoint_Scene, PxJoint, PxScene * > Scene;
		PxReadOnlyPropertyInfo<PxPropertyInfoName::PxJoint_Type, PxJoint, PxJointType::Enum > Type;
		PxReadOnlyPropertyInfo<PxPropertyInfoName::PxJoint_ClassName, PxJoint, const char * > ClassName;
		PxPropertyInfo<PxPropertyInfoName::PxJoint_UserData, PxJoint, void *, void * > UserData;

		PxJointGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			inOperator( (PxJoint*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator ) const
		{
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			return inStartIndex;
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( Actors, inStartIndex + 0 );
			inOperator( LocalPose, inStartIndex + 1 );
			inOperator( BreakForce, inStartIndex + 2 );
			inOperator( ConstraintFlags, inStartIndex + 3 );
			inOperator( Name, inStartIndex + 4 );
			inOperator( Scene, inStartIndex + 5 );
			inOperator( Type, inStartIndex + 6 );
			inOperator( ClassName, inStartIndex + 7 );
			inOperator( UserData, inStartIndex + 8 );
			return 9 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxJoint> { PxJointGeneratedInfo Info; };

	static PxU32ToName g_PxDistanceJointFlag__EnumConversion[] = {
		{ "eMAX_DISTANCE_ENABLED", static_cast<PxU32>( PxDistanceJointFlag::eMAX_DISTANCE_ENABLED ) },
		{ "eMIN_DISTANCE_ENABLED", static_cast<PxU32>( PxDistanceJointFlag::eMIN_DISTANCE_ENABLED ) },
		{ "eSPRING_ENABLED", static_cast<PxU32>( PxDistanceJointFlag::eSPRING_ENABLED ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< PxDistanceJointFlag::Enum > { PxEnumTraits() : NameConversion( g_PxDistanceJointFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxDistanceJoint;
	struct PxDistanceJointGeneratedInfo
		: PxJointGeneratedInfo
	{
		static const char* getClassName() { return "PxDistanceJoint"; }
		PxPropertyInfo<PxPropertyInfoName::PxDistanceJoint_MinDistance, PxDistanceJoint, PxReal, PxReal > MinDistance;
		PxPropertyInfo<PxPropertyInfoName::PxDistanceJoint_MaxDistance, PxDistanceJoint, PxReal, PxReal > MaxDistance;
		PxPropertyInfo<PxPropertyInfoName::PxDistanceJoint_Tolerance, PxDistanceJoint, PxReal, PxReal > Tolerance;
		PxPropertyInfo<PxPropertyInfoName::PxDistanceJoint_Spring, PxDistanceJoint, PxReal, PxReal > Spring;
		PxPropertyInfo<PxPropertyInfoName::PxDistanceJoint_Damping, PxDistanceJoint, PxReal, PxReal > Damping;
		PxPropertyInfo<PxPropertyInfoName::PxDistanceJoint_DistanceJointFlags, PxDistanceJoint, PxDistanceJointFlags, PxDistanceJointFlags > DistanceJointFlags;
		PxReadOnlyPropertyInfo<PxPropertyInfoName::PxDistanceJoint_ClassName, PxDistanceJoint, const char * > ClassName;

		PxDistanceJointGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			inOperator( (PxDistanceJoint*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator ) const
		{
			inOperator( *static_cast<PxJointGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxJointGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxJointGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( MinDistance, inStartIndex + 0 );
			inOperator( MaxDistance, inStartIndex + 1 );
			inOperator( Tolerance, inStartIndex + 2 );
			inOperator( Spring, inStartIndex + 3 );
			inOperator( Damping, inStartIndex + 4 );
			inOperator( DistanceJointFlags, inStartIndex + 5 );
			inOperator( ClassName, inStartIndex + 6 );
			return 7 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxDistanceJoint> { PxDistanceJointGeneratedInfo Info; };

	class PxFixedJoint;
	struct PxFixedJointGeneratedInfo
		: PxJointGeneratedInfo
	{
		static const char* getClassName() { return "PxFixedJoint"; }
		PxPropertyInfo<PxPropertyInfoName::PxFixedJoint_ProjectionLinearTolerance, PxFixedJoint, PxReal, PxReal > ProjectionLinearTolerance;
		PxPropertyInfo<PxPropertyInfoName::PxFixedJoint_ProjectionAngularTolerance, PxFixedJoint, PxReal, PxReal > ProjectionAngularTolerance;
		PxReadOnlyPropertyInfo<PxPropertyInfoName::PxFixedJoint_ClassName, PxFixedJoint, const char * > ClassName;

		PxFixedJointGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			inOperator( (PxFixedJoint*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator ) const
		{
			inOperator( *static_cast<PxJointGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxJointGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxJointGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( ProjectionLinearTolerance, inStartIndex + 0 );
			inOperator( ProjectionAngularTolerance, inStartIndex + 1 );
			inOperator( ClassName, inStartIndex + 2 );
			return 3 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxFixedJoint> { PxFixedJointGeneratedInfo Info; };

	class PxJointLimitParameters;
	struct PxJointLimitParametersGeneratedInfo

	{
		static const char* getClassName() { return "PxJointLimitParameters"; }
		PxReadOnlyPropertyInfo<PxPropertyInfoName::PxJointLimitParameters_Valid, PxJointLimitParameters, _Bool > Valid;
		PxPropertyInfo<PxPropertyInfoName::PxJointLimitParameters_Restitution, PxJointLimitParameters, float, float > Restitution;
		PxPropertyInfo<PxPropertyInfoName::PxJointLimitParameters_Spring, PxJointLimitParameters, float, float > Spring;
		PxPropertyInfo<PxPropertyInfoName::PxJointLimitParameters_Damping, PxJointLimitParameters, float, float > Damping;
		PxPropertyInfo<PxPropertyInfoName::PxJointLimitParameters_ContactDistance, PxJointLimitParameters, float, float > ContactDistance;

		PxJointLimitParametersGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			inOperator( (PxJointLimitParameters*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator ) const
		{
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			return inStartIndex;
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( Valid, inStartIndex + 0 );
			inOperator( Restitution, inStartIndex + 1 );
			inOperator( Spring, inStartIndex + 2 );
			inOperator( Damping, inStartIndex + 3 );
			inOperator( ContactDistance, inStartIndex + 4 );
			return 5 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxJointLimitParameters> { PxJointLimitParametersGeneratedInfo Info; };

	class PxJointLimit;
	struct PxJointLimitGeneratedInfo
		: PxJointLimitParametersGeneratedInfo
	{
		static const char* getClassName() { return "PxJointLimit"; }
		PxReadOnlyPropertyInfo<PxPropertyInfoName::PxJointLimit_Valid, PxJointLimit, _Bool > Valid;
		PxPropertyInfo<PxPropertyInfoName::PxJointLimit_Value, PxJointLimit, float, float > Value;

		PxJointLimitGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			inOperator( (PxJointLimit*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator ) const
		{
			inOperator( *static_cast<PxJointLimitParametersGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxJointLimitParametersGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxJointLimitParametersGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( Valid, inStartIndex + 0 );
			inOperator( Value, inStartIndex + 1 );
			return 2 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxJointLimit> { PxJointLimitGeneratedInfo Info; };

	class PxJointLimitPair;
	struct PxJointLimitPairGeneratedInfo
		: PxJointLimitParametersGeneratedInfo
	{
		static const char* getClassName() { return "PxJointLimitPair"; }
		PxReadOnlyPropertyInfo<PxPropertyInfoName::PxJointLimitPair_Valid, PxJointLimitPair, _Bool > Valid;
		PxPropertyInfo<PxPropertyInfoName::PxJointLimitPair_Upper, PxJointLimitPair, float, float > Upper;
		PxPropertyInfo<PxPropertyInfoName::PxJointLimitPair_Lower, PxJointLimitPair, float, float > Lower;

		PxJointLimitPairGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			inOperator( (PxJointLimitPair*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator ) const
		{
			inOperator( *static_cast<PxJointLimitParametersGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxJointLimitParametersGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxJointLimitParametersGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( Valid, inStartIndex + 0 );
			inOperator( Upper, inStartIndex + 1 );
			inOperator( Lower, inStartIndex + 2 );
			return 3 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxJointLimitPair> { PxJointLimitPairGeneratedInfo Info; };

	class PxJointLimitCone;
	struct PxJointLimitConeGeneratedInfo
		: PxJointLimitParametersGeneratedInfo
	{
		static const char* getClassName() { return "PxJointLimitCone"; }
		PxReadOnlyPropertyInfo<PxPropertyInfoName::PxJointLimitCone_Valid, PxJointLimitCone, _Bool > Valid;
		PxPropertyInfo<PxPropertyInfoName::PxJointLimitCone_YAngle, PxJointLimitCone, float, float > YAngle;
		PxPropertyInfo<PxPropertyInfoName::PxJointLimitCone_ZAngle, PxJointLimitCone, float, float > ZAngle;

		PxJointLimitConeGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			inOperator( (PxJointLimitCone*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator ) const
		{
			inOperator( *static_cast<PxJointLimitParametersGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxJointLimitParametersGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxJointLimitParametersGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( Valid, inStartIndex + 0 );
			inOperator( YAngle, inStartIndex + 1 );
			inOperator( ZAngle, inStartIndex + 2 );
			return 3 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxJointLimitCone> { PxJointLimitConeGeneratedInfo Info; };

	static PxU32ToName g_PxPrismaticJointFlag__EnumConversion[] = {
		{ "eLIMIT_ENABLED", static_cast<PxU32>( PxPrismaticJointFlag::eLIMIT_ENABLED ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< PxPrismaticJointFlag::Enum > { PxEnumTraits() : NameConversion( g_PxPrismaticJointFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxPrismaticJoint;
	struct PxPrismaticJointGeneratedInfo
		: PxJointGeneratedInfo
	{
		static const char* getClassName() { return "PxPrismaticJoint"; }
		PxPropertyInfo<PxPropertyInfoName::PxPrismaticJoint_Limit, PxPrismaticJoint, const PxJointLimitPair &, PxJointLimitPair > Limit;
		PxPropertyInfo<PxPropertyInfoName::PxPrismaticJoint_PrismaticJointFlags, PxPrismaticJoint, PxPrismaticJointFlags, PxPrismaticJointFlags > PrismaticJointFlags;
		PxPropertyInfo<PxPropertyInfoName::PxPrismaticJoint_ProjectionLinearTolerance, PxPrismaticJoint, PxReal, PxReal > ProjectionLinearTolerance;
		PxPropertyInfo<PxPropertyInfoName::PxPrismaticJoint_ProjectionAngularTolerance, PxPrismaticJoint, PxReal, PxReal > ProjectionAngularTolerance;
		PxReadOnlyPropertyInfo<PxPropertyInfoName::PxPrismaticJoint_ClassName, PxPrismaticJoint, const char * > ClassName;

		PxPrismaticJointGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			inOperator( (PxPrismaticJoint*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator ) const
		{
			inOperator( *static_cast<PxJointGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxJointGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxJointGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( Limit, inStartIndex + 0 );
			inOperator( PrismaticJointFlags, inStartIndex + 1 );
			inOperator( ProjectionLinearTolerance, inStartIndex + 2 );
			inOperator( ProjectionAngularTolerance, inStartIndex + 3 );
			inOperator( ClassName, inStartIndex + 4 );
			return 5 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxPrismaticJoint> { PxPrismaticJointGeneratedInfo Info; };

	static PxU32ToName g_PxRevoluteJointFlag__EnumConversion[] = {
		{ "eLIMIT_ENABLED", static_cast<PxU32>( PxRevoluteJointFlag::eLIMIT_ENABLED ) },
		{ "eDRIVE_ENABLED", static_cast<PxU32>( PxRevoluteJointFlag::eDRIVE_ENABLED ) },
		{ "eDRIVE_FREESPIN", static_cast<PxU32>( PxRevoluteJointFlag::eDRIVE_FREESPIN ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< PxRevoluteJointFlag::Enum > { PxEnumTraits() : NameConversion( g_PxRevoluteJointFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxRevoluteJoint;
	struct PxRevoluteJointGeneratedInfo
		: PxJointGeneratedInfo
	{
		static const char* getClassName() { return "PxRevoluteJoint"; }
		PxPropertyInfo<PxPropertyInfoName::PxRevoluteJoint_Limit, PxRevoluteJoint, const PxJointLimitPair &, PxJointLimitPair > Limit;
		PxPropertyInfo<PxPropertyInfoName::PxRevoluteJoint_DriveVelocity, PxRevoluteJoint, PxReal, PxReal > DriveVelocity;
		PxPropertyInfo<PxPropertyInfoName::PxRevoluteJoint_DriveForceLimit, PxRevoluteJoint, PxReal, PxReal > DriveForceLimit;
		PxPropertyInfo<PxPropertyInfoName::PxRevoluteJoint_DriveGearRatio, PxRevoluteJoint, PxReal, PxReal > DriveGearRatio;
		PxPropertyInfo<PxPropertyInfoName::PxRevoluteJoint_RevoluteJointFlags, PxRevoluteJoint, PxRevoluteJointFlags, PxRevoluteJointFlags > RevoluteJointFlags;
		PxPropertyInfo<PxPropertyInfoName::PxRevoluteJoint_ProjectionLinearTolerance, PxRevoluteJoint, PxReal, PxReal > ProjectionLinearTolerance;
		PxPropertyInfo<PxPropertyInfoName::PxRevoluteJoint_ProjectionAngularTolerance, PxRevoluteJoint, PxReal, PxReal > ProjectionAngularTolerance;
		PxReadOnlyPropertyInfo<PxPropertyInfoName::PxRevoluteJoint_ClassName, PxRevoluteJoint, const char * > ClassName;

		PxRevoluteJointGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			inOperator( (PxRevoluteJoint*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator ) const
		{
			inOperator( *static_cast<PxJointGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxJointGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxJointGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( Limit, inStartIndex + 0 );
			inOperator( DriveVelocity, inStartIndex + 1 );
			inOperator( DriveForceLimit, inStartIndex + 2 );
			inOperator( DriveGearRatio, inStartIndex + 3 );
			inOperator( RevoluteJointFlags, inStartIndex + 4 );
			inOperator( ProjectionLinearTolerance, inStartIndex + 5 );
			inOperator( ProjectionAngularTolerance, inStartIndex + 6 );
			inOperator( ClassName, inStartIndex + 7 );
			return 8 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxRevoluteJoint> { PxRevoluteJointGeneratedInfo Info; };

	static PxU32ToName g_PxSphericalJointFlag__EnumConversion[] = {
		{ "eLIMIT_ENABLED", static_cast<PxU32>( PxSphericalJointFlag::eLIMIT_ENABLED ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< PxSphericalJointFlag::Enum > { PxEnumTraits() : NameConversion( g_PxSphericalJointFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxSphericalJoint;
	struct PxSphericalJointGeneratedInfo
		: PxJointGeneratedInfo
	{
		static const char* getClassName() { return "PxSphericalJoint"; }
		PxPropertyInfo<PxPropertyInfoName::PxSphericalJoint_LimitCone, PxSphericalJoint, const PxJointLimitCone &, PxJointLimitCone > LimitCone;
		PxPropertyInfo<PxPropertyInfoName::PxSphericalJoint_SphericalJointFlags, PxSphericalJoint, PxSphericalJointFlags, PxSphericalJointFlags > SphericalJointFlags;
		PxPropertyInfo<PxPropertyInfoName::PxSphericalJoint_ProjectionLinearTolerance, PxSphericalJoint, PxReal, PxReal > ProjectionLinearTolerance;
		PxReadOnlyPropertyInfo<PxPropertyInfoName::PxSphericalJoint_ClassName, PxSphericalJoint, const char * > ClassName;

		PxSphericalJointGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			inOperator( (PxSphericalJoint*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator ) const
		{
			inOperator( *static_cast<PxJointGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxJointGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxJointGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( LimitCone, inStartIndex + 0 );
			inOperator( SphericalJointFlags, inStartIndex + 1 );
			inOperator( ProjectionLinearTolerance, inStartIndex + 2 );
			inOperator( ClassName, inStartIndex + 3 );
			return 4 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxSphericalJoint> { PxSphericalJointGeneratedInfo Info; };

	static PxU32ToName g_PxD6Axis__EnumConversion[] = {
		{ "eX", static_cast<PxU32>( PxD6Axis::eX ) },
		{ "eY", static_cast<PxU32>( PxD6Axis::eY ) },
		{ "eZ", static_cast<PxU32>( PxD6Axis::eZ ) },
		{ "eTWIST", static_cast<PxU32>( PxD6Axis::eTWIST ) },
		{ "eSWING1", static_cast<PxU32>( PxD6Axis::eSWING1 ) },
		{ "eSWING2", static_cast<PxU32>( PxD6Axis::eSWING2 ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< PxD6Axis::Enum > { PxEnumTraits() : NameConversion( g_PxD6Axis__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	static PxU32ToName g_PxD6Motion__EnumConversion[] = {
		{ "eLOCKED", static_cast<PxU32>( PxD6Motion::eLOCKED ) },
		{ "eLIMITED", static_cast<PxU32>( PxD6Motion::eLIMITED ) },
		{ "eFREE", static_cast<PxU32>( PxD6Motion::eFREE ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< PxD6Motion::Enum > { PxEnumTraits() : NameConversion( g_PxD6Motion__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	static PxU32ToName g_PxD6Drive__EnumConversion[] = {
		{ "eX", static_cast<PxU32>( PxD6Drive::eX ) },
		{ "eY", static_cast<PxU32>( PxD6Drive::eY ) },
		{ "eZ", static_cast<PxU32>( PxD6Drive::eZ ) },
		{ "eSWING", static_cast<PxU32>( PxD6Drive::eSWING ) },
		{ "eTWIST", static_cast<PxU32>( PxD6Drive::eTWIST ) },
		{ "eSLERP", static_cast<PxU32>( PxD6Drive::eSLERP ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< PxD6Drive::Enum > { PxEnumTraits() : NameConversion( g_PxD6Drive__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxD6Joint;
	struct PxD6JointGeneratedInfo
		: PxJointGeneratedInfo
	{
		static const char* getClassName() { return "PxD6Joint"; }
		PxIndexedPropertyInfo<PxPropertyInfoName::PxD6Joint_Motion, PxD6Joint, PxD6Axis::Enum, PxD6Motion::Enum > Motion;
		PxPropertyInfo<PxPropertyInfoName::PxD6Joint_LinearLimit, PxD6Joint, const PxJointLimit &, PxJointLimit > LinearLimit;
		PxPropertyInfo<PxPropertyInfoName::PxD6Joint_TwistLimit, PxD6Joint, const PxJointLimitPair &, PxJointLimitPair > TwistLimit;
		PxPropertyInfo<PxPropertyInfoName::PxD6Joint_SwingLimit, PxD6Joint, const PxJointLimitCone &, PxJointLimitCone > SwingLimit;
		PxIndexedPropertyInfo<PxPropertyInfoName::PxD6Joint_Drive, PxD6Joint, PxD6Drive::Enum, PxD6JointDrive > Drive;
		PxPropertyInfo<PxPropertyInfoName::PxD6Joint_DrivePosition, PxD6Joint, const PxTransform &, PxTransform > DrivePosition;
		PxRangePropertyInfo<PxPropertyInfoName::PxD6Joint_DriveVelocity, PxD6Joint, PxVec3 > DriveVelocity;
		PxPropertyInfo<PxPropertyInfoName::PxD6Joint_ProjectionLinearTolerance, PxD6Joint, PxReal, PxReal > ProjectionLinearTolerance;
		PxPropertyInfo<PxPropertyInfoName::PxD6Joint_ProjectionAngularTolerance, PxD6Joint, PxReal, PxReal > ProjectionAngularTolerance;
		PxReadOnlyPropertyInfo<PxPropertyInfoName::PxD6Joint_ClassName, PxD6Joint, const char * > ClassName;

		PxD6JointGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			inOperator( (PxD6Joint*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator ) const
		{
			inOperator( *static_cast<PxJointGeneratedInfo*>( this ) );
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inStartIndex = PxJointGeneratedInfo::visitBaseProperties( inOperator, inStartIndex );
			inStartIndex = PxJointGeneratedInfo::visitInstanceProperties( inOperator, inStartIndex );
			return inStartIndex;
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( Motion, inStartIndex + 0 );
			inOperator( LinearLimit, inStartIndex + 1 );
			inOperator( TwistLimit, inStartIndex + 2 );
			inOperator( SwingLimit, inStartIndex + 3 );
			inOperator( Drive, inStartIndex + 4 );
			inOperator( DrivePosition, inStartIndex + 5 );
			inOperator( DriveVelocity, inStartIndex + 6 );
			inOperator( ProjectionLinearTolerance, inStartIndex + 7 );
			inOperator( ProjectionAngularTolerance, inStartIndex + 8 );
			inOperator( ClassName, inStartIndex + 9 );
			return 10 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxD6Joint> { PxD6JointGeneratedInfo Info; };

	static PxU32ToName g_PxD6JointDriveFlag__EnumConversion[] = {
		{ "eACCELERATION", static_cast<PxU32>( PxD6JointDriveFlag::eACCELERATION ) },
		{ NULL, 0 }
	};

template<> struct PxEnumTraits< PxD6JointDriveFlag::Enum > { PxEnumTraits() : NameConversion( g_PxD6JointDriveFlag__EnumConversion ) {} const PxU32ToName* NameConversion; }; 
	class PxD6JointDrive;
	struct PxD6JointDriveGeneratedInfo

	{
		static const char* getClassName() { return "PxD6JointDrive"; }
		PxReadOnlyPropertyInfo<PxPropertyInfoName::PxD6JointDrive_Valid, PxD6JointDrive, _Bool > Valid;
		PxPropertyInfo<PxPropertyInfoName::PxD6JointDrive_Spring, PxD6JointDrive, float, float > Spring;
		PxPropertyInfo<PxPropertyInfoName::PxD6JointDrive_Damping, PxD6JointDrive, float, float > Damping;
		PxPropertyInfo<PxPropertyInfoName::PxD6JointDrive_ForceLimit, PxD6JointDrive, float, float > ForceLimit;
		PxPropertyInfo<PxPropertyInfoName::PxD6JointDrive_Flags, PxD6JointDrive, PxFlags<PxD6JointDriveFlag::Enum, PxU32>, PxFlags<PxD6JointDriveFlag::Enum, PxU32> > Flags;

		PxD6JointDriveGeneratedInfo();
		template<typename TReturnType, typename TOperator>
		TReturnType visitType( TOperator inOperator ) const
		{
			inOperator( (PxD6JointDrive*)NULL );
		}
		template<typename TOperator>
		void visitBases( TOperator inOperator ) const
		{
		}
		template<typename TOperator>
		PxU32 visitBaseProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			return inStartIndex;
		}
		template<typename TOperator>
		PxU32 visitInstanceProperties( TOperator inOperator, PxU32 inStartIndex = 0 ) const
		{
			inOperator( Valid, inStartIndex + 0 );
			inOperator( Spring, inStartIndex + 1 );
			inOperator( Damping, inStartIndex + 2 );
			inOperator( ForceLimit, inStartIndex + 3 );
			inOperator( Flags, inStartIndex + 4 );
			return 5 + inStartIndex;
		}
	};
	template<> struct PxClassInfoTraits<PxD6JointDrive> { PxD6JointDriveGeneratedInfo Info; };



#undef THERE_IS_NO_INCLUDE_GUARD_HERE_FOR_A_REASON
